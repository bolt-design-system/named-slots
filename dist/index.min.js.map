{"version":3,"file":"index.min.js","sources":["../src/util/each.js","../src/util/get-property-descriptor.js","../src/util/can-patch-native-accessors.js","../node_modules/date-now/index.js","../node_modules/debounce/index.js","../src/util/get-escaped-text-content.js","../src/util/get-comment-node-outer-html.js","../src/version.js","../node_modules/weakmap/weakmap.js","../node_modules/custom-event-polyfill/custom-event-polyfill.js","../src/index.js"],"sourcesContent":["export function eachChildNode (node, func) {\n  if (!node) {\n    return;\n  }\n\n  const chs = node.childNodes;\n  const chsLen = chs.length;\n  for (let a = 0; a < chsLen; a++) {\n    const ret = func(chs[a], a, chs);\n    if (typeof ret !== 'undefined') {\n      return ret;\n    }\n  }\n}\n\nexport function eachNodeOrFragmentNodes (node, func) {\n  if (node instanceof DocumentFragment) {\n    const chs = node.childNodes;\n    const chsLen = chs.length;\n    for (let a = 0; a < chsLen; a++) {\n      func(chs[a], a);\n    }\n  } else {\n    func(node, 0);\n  }\n}\n","const div = document.createElement('div');\n\nfunction getPrototype(obj, key) {\n  let descriptor;\n\n  while (obj && !(descriptor = Object.getOwnPropertyDescriptor(obj, key))) {\n    obj = Object.getPrototypeOf(obj);\n  }\n  return descriptor;\n}\nexport default function (obj, key) {\n  if (obj instanceof Node) {\n    obj = div;\n  }\n  let proto = getPrototype(obj, key);\n\n  if (proto) {\n    const getter = proto.get;\n    const setter = proto.set;\n    const descriptor = {\n      configurable: true,\n      enumerable: true\n    };\n\n    if (getter) {\n      descriptor.get = getter;\n      descriptor.set = setter;\n      return descriptor;\n    } else if (typeof obj[key] === 'function') {\n      descriptor.value = obj[key];\n      return descriptor;\n    }\n  }\n\n  const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n  if (descriptor && descriptor.get) {\n    return descriptor;\n  }\n}\n","// Any code referring to this is because it has to work around this bug in\n// WebKit: https://bugs.webkit.org/show_bug.cgi?id=49739\n\nimport getPropertyDescriptor from './get-property-descriptor';\n\nconst nativeParentNode = getPropertyDescriptor(Element.prototype, 'innerHTML');\n\nexport default !!nativeParentNode;\n","module.exports = Date.now || now\n\nfunction now() {\n    return new Date().getTime()\n}\n","\n/**\n * Module dependencies.\n */\n\nvar now = require('date-now');\n\n/**\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * N milliseconds. If `immediate` is passed, trigger the function on the\n * leading edge, instead of the trailing.\n *\n * @source underscore.js\n * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n * @param {Function} function to wrap\n * @param {Number} timeout in ms (`100`)\n * @param {Boolean} whether to execute at the beginning (`false`)\n * @api public\n */\n\nmodule.exports = function debounce(func, wait, immediate){\n  var timeout, args, context, timestamp, result;\n  if (null == wait) wait = 100;\n\n  function later() {\n    var last = now() - timestamp;\n\n    if (last < wait && last > 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      if (!immediate) {\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      }\n    }\n  };\n\n  return function debounced() {\n    context = this;\n    args = arguments;\n    timestamp = now();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n};\n","/**\n * See https://w3c.github.io/DOM-Parsing/#serializing\n * @param {TextNode}\n * @returns {string}\n */\nexport default function getEscapedTextContent (textNode) {\n  return textNode.textContent.replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;');\n}\n","/**\n * @returns {string}\n * @param {commentNode}\n */\nexport default function getCommentNodeOuterHtml (commentNode) {\n  return commentNode.text || `<!--${commentNode.textContent}-->`;\n}\n","export default '0.0.1';\n","/* (The MIT License)\r\n *\r\n * Copyright (c) 2012 Brandon Benvie <http://bbenvie.com>\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and\r\n * associated documentation files (the 'Software'), to deal in the Software without restriction,\r\n * including without limitation the rights to use, copy, modify, merge, publish, distribute,\r\n * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included with all copies or\r\n * substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\r\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  CLAIM,\r\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n// Original WeakMap implementation by Gozala @ https://gist.github.com/1269991\r\n// Updated and bugfixed by Raynos @ https://gist.github.com/1638059\r\n// Expanded by Benvie @ https://github.com/Benvie/harmony-collections\r\n\r\nvoid function(global, undefined_, undefined){\r\n  var getProps = Object.getOwnPropertyNames,\r\n      defProp  = Object.defineProperty,\r\n      toSource = Function.prototype.toString,\r\n      create   = Object.create,\r\n      hasOwn   = Object.prototype.hasOwnProperty,\r\n      funcName = /^\\n?function\\s?(\\w*)?_?\\(/;\r\n\r\n\r\n  function define(object, key, value){\r\n    if (typeof key === 'function') {\r\n      value = key;\r\n      key = nameOf(value).replace(/_$/, '');\r\n    }\r\n    return defProp(object, key, { configurable: true, writable: true, value: value });\r\n  }\r\n\r\n  function nameOf(func){\r\n    return typeof func !== 'function'\r\n          ? '' : 'name' in func\r\n          ? func.name : toSource.call(func).match(funcName)[1];\r\n  }\r\n\r\n  // ############\r\n  // ### Data ###\r\n  // ############\r\n\r\n  var Data = (function(){\r\n    var dataDesc = { value: { writable: true, value: undefined } },\r\n        datalock = 'return function(k){if(k===s)return l}',\r\n        uids     = create(null),\r\n\r\n        createUID = function(){\r\n          var key = Math.random().toString(36).slice(2);\r\n          return key in uids ? createUID() : uids[key] = key;\r\n        },\r\n\r\n        globalID = createUID(),\r\n\r\n        storage = function(obj){\r\n          if (hasOwn.call(obj, globalID))\r\n            return obj[globalID];\r\n\r\n          if (!Object.isExtensible(obj))\r\n            throw new TypeError(\"Object must be extensible\");\r\n\r\n          var store = create(null);\r\n          defProp(obj, globalID, { value: store });\r\n          return store;\r\n        };\r\n\r\n    // common per-object storage area made visible by patching getOwnPropertyNames'\r\n    define(Object, function getOwnPropertyNames(obj){\r\n      var props = getProps(obj);\r\n      if (hasOwn.call(obj, globalID))\r\n        props.splice(props.indexOf(globalID), 1);\r\n      return props;\r\n    });\r\n\r\n    function Data(){\r\n      var puid = createUID(),\r\n          secret = {};\r\n\r\n      this.unlock = function(obj){\r\n        var store = storage(obj);\r\n        if (hasOwn.call(store, puid))\r\n          return store[puid](secret);\r\n\r\n        var data = create(null, dataDesc);\r\n        defProp(store, puid, {\r\n          value: new Function('s', 'l', datalock)(secret, data)\r\n        });\r\n        return data;\r\n      }\r\n    }\r\n\r\n    define(Data.prototype, function get(o){ return this.unlock(o).value });\r\n    define(Data.prototype, function set(o, v){ this.unlock(o).value = v });\r\n\r\n    return Data;\r\n  }());\r\n\r\n\r\n  var WM = (function(data){\r\n    var validate = function(key){\r\n      if (key == null || typeof key !== 'object' && typeof key !== 'function')\r\n        throw new TypeError(\"Invalid WeakMap key\");\r\n    }\r\n\r\n    var wrap = function(collection, value){\r\n      var store = data.unlock(collection);\r\n      if (store.value)\r\n        throw new TypeError(\"Object is already a WeakMap\");\r\n      store.value = value;\r\n    }\r\n\r\n    var unwrap = function(collection){\r\n      var storage = data.unlock(collection).value;\r\n      if (!storage)\r\n        throw new TypeError(\"WeakMap is not generic\");\r\n      return storage;\r\n    }\r\n\r\n    var initialize = function(weakmap, iterable){\r\n      if (iterable !== null && typeof iterable === 'object' && typeof iterable.forEach === 'function') {\r\n        iterable.forEach(function(item, i){\r\n          if (item instanceof Array && item.length === 2)\r\n            set.call(weakmap, iterable[i][0], iterable[i][1]);\r\n        });\r\n      }\r\n    }\r\n\r\n\r\n    function WeakMap(iterable){\r\n      if (this === global || this == null || this === WeakMap.prototype)\r\n        return new WeakMap(iterable);\r\n\r\n      wrap(this, new Data);\r\n      initialize(this, iterable);\r\n    }\r\n\r\n    function get(key){\r\n      validate(key);\r\n      var value = unwrap(this).get(key);\r\n      return value === undefined_ ? undefined : value;\r\n    }\r\n\r\n    function set(key, value){\r\n      validate(key);\r\n      // store a token for explicit undefined so that \"has\" works correctly\r\n      unwrap(this).set(key, value === undefined ? undefined_ : value);\r\n    }\r\n\r\n    function has(key){\r\n      validate(key);\r\n      return unwrap(this).get(key) !== undefined;\r\n    }\r\n\r\n    function delete_(key){\r\n      validate(key);\r\n      var data = unwrap(this),\r\n          had = data.get(key) !== undefined;\r\n      data.set(key, undefined);\r\n      return had;\r\n    }\r\n\r\n    function toString(){\r\n      unwrap(this);\r\n      return '[object WeakMap]';\r\n    }\r\n\r\n    try {\r\n      var src = ('return '+delete_).replace('e_', '\\\\u0065'),\r\n          del = new Function('unwrap', 'validate', src)(unwrap, validate);\r\n    } catch (e) {\r\n      var del = delete_;\r\n    }\r\n\r\n    var src = (''+Object).split('Object');\r\n    var stringifier = function toString(){\r\n      return src[0] + nameOf(this) + src[1];\r\n    };\r\n\r\n    define(stringifier, stringifier);\r\n\r\n    var prep = { __proto__: [] } instanceof Array\r\n      ? function(f){ f.__proto__ = stringifier }\r\n      : function(f){ define(f, stringifier) };\r\n\r\n    prep(WeakMap);\r\n\r\n    [toString, get, set, has, del].forEach(function(method){\r\n      define(WeakMap.prototype, method);\r\n      prep(method);\r\n    });\r\n\r\n    return WeakMap;\r\n  }(new Data));\r\n\r\n  var defaultCreator = Object.create\r\n    ? function(){ return Object.create(null) }\r\n    : function(){ return {} };\r\n\r\n  function createStorage(creator){\r\n    var weakmap = new WM;\r\n    creator || (creator = defaultCreator);\r\n\r\n    function storage(object, value){\r\n      if (value || arguments.length === 2) {\r\n        weakmap.set(object, value);\r\n      } else {\r\n        value = weakmap.get(object);\r\n        if (value === undefined) {\r\n          value = creator(object);\r\n          weakmap.set(object, value);\r\n        }\r\n      }\r\n      return value;\r\n    }\r\n\r\n    return storage;\r\n  }\r\n\r\n\r\n  if (typeof module !== 'undefined') {\r\n    module.exports = WM;\r\n  } else if (typeof exports !== 'undefined') {\r\n    exports.WeakMap = WM;\r\n  } else if (!('WeakMap' in global)) {\r\n    global.WeakMap = WM;\r\n  }\r\n\r\n  WM.createStorage = createStorage;\r\n  if (global.WeakMap)\r\n    global.WeakMap.createStorage = createStorage;\r\n}((0, eval)('this'));\r\n","// Polyfill for creating CustomEvents on IE9/10/11\n\n// code pulled from:\n// https://github.com/d4tocchini/customevent-polyfill\n// https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent#Polyfill\n\ntry {\n    var ce = new window.CustomEvent('test', {\n        bubbles: false,\n        cancelable: true,\n        detail: {\n            x: 'y'\n        }\n    });\n    ce.preventDefault();\n    if (ce.defaultPrevented !== true) {\n        // IE has problems with .preventDefault() on custom events\n        // http://stackoverflow.com/questions/23349191\n        throw new Error('Could not prevent default');\n    }\n} catch(e) {\n var CustomEvent = function(event, params) {\n      var evt;\n      params = params || {\n          bubbles: false,\n          cancelable: false,\n          detail: undefined\n      };\n\n      evt = document.createEvent(\"CustomEvent\");\n      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n      var origPrevent = evt.preventDefault;\n      evt.preventDefault = function () {\n          origPrevent.call(this);\n          try {\n              Object.defineProperty(this, 'defaultPrevented', {\n                  get: function () {\n                      return true;\n                  }\n              });\n          } catch(e) {\n              this.defaultPrevented = true;\n          }\n      };\n      return evt;\n  };\n\n  CustomEvent.prototype = window.Event.prototype;\n  window.CustomEvent = CustomEvent; // expose definition to window\n}\n","import { eachChildNode, eachNodeOrFragmentNodes } from './util/each';\nimport canPatchNativeAccessors from './util/can-patch-native-accessors';\nimport getPropertyDescriptor from './util/get-property-descriptor';\nimport debounce from 'debounce';\nimport getEscapedTextContent from './util/get-escaped-text-content';\nimport getCommentNodeOuterHtml from './util/get-comment-node-outer-html';\nimport version from './version';\nimport WeakMap from 'weakmap';\nimport 'custom-event-polyfill';\n\nconst arrProto = Array.prototype;\nconst { forEach } = arrProto;\n\n// We use a real DOM node for a shadow root. This is because the host node\n// basically becomes a virtual entry point for your element leaving the shadow\n// root the only thing that can receive instructions on how the host should\n// render to the browser.\nconst defaultShadowRootTagName = '_shadow_root_';\nconst defaultShadowRootTagNameUc = defaultShadowRootTagName.toUpperCase();\n\n// * WebKit only *\n//\n// These members we need cannot override as we require native access to their\n// original values at some point.\nconst polyfillAtRuntime = ['childNodes', 'parentNode'];\n\n// Some properties that should not be overridden in the Text prototype.\nconst doNotOverridePropertiesInTextNodes = ['textContent'];\n\n// Some new properties that should be defined in the Text prototype.\nconst defineInTextNodes = ['assignedSlot'];\n\n// Some properties that should not be overridden in the Comment prototype.\nconst doNotOverridePropertiesInCommNodes = ['textContent'];\n\n// Some new properties that should be defined in the Comment prototype.\nconst defineInCommNodes = [];\n\n// Nodes that should be slotted\nconst slottedNodeTypes = [Node.ELEMENT_NODE, Node.TEXT_NODE];\n\n// Private data stores.\nconst assignedToSlotMap = new WeakMap();\nconst hostToModeMap = new WeakMap();\nconst hostToRootMap = new WeakMap();\nconst nodeToChildNodesMap = new WeakMap();\nconst nodeToParentNodeMap = new WeakMap();\nconst nodeToSlotMap = new WeakMap();\nconst rootToHostMap = new WeakMap();\nconst rootToSlotMap = new WeakMap();\nconst slotToRootMap = new WeakMap();\n\n\n// Unfortunately manual DOM parsing is because of WebKit.\nconst parser = new DOMParser();\nfunction parse (html) {\n  const tree = document.createElement('div');\n\n  // Everything not WebKit can do this easily.\n  if (canPatchNativeAccessors) {\n    tree.__innerHTML = html;\n    return tree;\n  }\n\n  const parsed = parser.parseFromString(`<div>${html}</div>`, 'text/html').body.firstChild;\n\n  while (parsed.hasChildNodes()) {\n    const firstChild = parsed.firstChild;\n    parsed.removeChild(firstChild);\n    tree.appendChild(firstChild);\n  }\n\n  // Need to import the node to initialise the custom elements from the parser.\n  return document.importNode(tree, true);\n}\n\nfunction staticProp (obj, name, value) {\n  Object.defineProperty(obj, name, {\n    configurable: true,\n    get () { return value; }\n  });\n}\n\n\n// Slotting helpers.\n\nfunction arrayItem (idx) {\n  return this[idx];\n}\n\nfunction makeLikeNodeList (arr) {\n  arr.item = arrayItem;\n  return arr;\n}\n\nfunction getNodeType (node) {\n  if (isHostNode(node)) {\n    return 'host';\n  }\n\n  if (isSlotNode(node)) {\n    return 'slot';\n  }\n\n  if (isRootNode(node)) {\n    return 'root';\n  }\n\n  return 'node';\n}\n\nfunction isHostNode (node) {\n  return !!hostToRootMap.get(node);\n}\n\nfunction isSlotNode (node) {\n  return node.tagName === 'SLOT';\n}\n\nfunction isRootNode (node) {\n  return node.tagName === defaultShadowRootTagNameUc;\n}\n\nfunction findClosest (node, func) {\n  while (node) {\n    if (node === document) {\n      break;\n    }\n    if (func(node)) {\n      return node;\n    }\n    node = node.parentNode;\n  }\n}\n\nfunction getSlotNameFromSlot (node) {\n  return node.getAttribute && node.getAttribute('name') || 'default';\n}\n\nfunction getSlotNameFromNode (node) {\n  return node.getAttribute && node.getAttribute('slot') || 'default';\n}\n\nfunction slotNodeIntoSlot (slot, node, insertBefore) {\n  // Don't slot nodes that have content but are only whitespace. This is an\n  // anomaly that I don't think the spec deals with.\n  //\n  // The problem is:\n  //\n  // - If you insert HTML with indentation into the page, there will be\n  //   whitespace and if that's inserted it messes with fallback content\n  //   calculation where there is formatting, but no meaningful content, so in\n  //   theory it should fallback. Since you can attach a shadow root after we\n  //   mean to insert an empty text node and have it \"count\", we can't really\n  //   discard nodes that are considered formatting at the time of attachment.\n  // - You can insert a text node and modify its text content later.\n  //   Incremental DOM seems to do this. Every way I look at it, it seems\n  //   problematic that we should have to screen for content, but I don't seems\n  //   much of a way around it at the moment.\n  if (node.nodeType === 3 && node.textContent && node.textContent.trim().length === 0) {\n    return;\n  }\n\n  // only Text and Element nodes should be slotted\n  if (slottedNodeTypes.indexOf(node.nodeType) === -1) {\n    return;\n  }\n\n  const assignedNodes = slot.assignedNodes();\n  const shouldGoIntoContentMode = assignedNodes.length === 0;\n  const slotInsertBeforeIndex = assignedNodes.indexOf(insertBefore);\n\n  // Assign the slot to the node internally.\n  nodeToSlotMap.set(node, slot);\n\n  // Remove the fallback content and state if we're going into content mode.\n  if (shouldGoIntoContentMode) {\n    forEach.call(slot.childNodes, node => slot.__removeChild(node));\n  }\n\n  if (slotInsertBeforeIndex > -1) {\n    slot.__insertBefore(node, insertBefore !== undefined ? insertBefore : null);\n    assignedNodes.splice(slotInsertBeforeIndex, 0, node);\n  } else {\n    slot.__appendChild(node);\n    assignedNodes.push(node);\n  }\n\n  slot.____triggerSlotChangeEvent();\n}\n\nfunction slotNodeFromSlot (node) {\n  const slot = node.assignedSlot;\n\n  if (slot) {\n    const assignedNodes = slot.assignedNodes();\n    const index = assignedNodes.indexOf(node);\n\n    if (index > -1) {\n      const shouldGoIntoDefaultMode = assignedNodes.length === 1;\n\n      assignedNodes.splice(index, 1);\n      nodeToSlotMap.set(node, null);\n\n      // Actually remove the child.\n      slot.__removeChild(node);\n\n      // If this was the last slotted node, then insert fallback content.\n      if (shouldGoIntoDefaultMode) {\n        forEach.call(slot.childNodes, node => slot.__appendChild(node));\n      }\n\n      slot.____triggerSlotChangeEvent();\n    }\n  }\n}\n\n// Returns the index of the node in the host's childNodes.\nfunction indexOfNode (host, node) {\n  const chs = host.childNodes;\n  const chsLen = chs.length;\n  for (let a = 0; a < chsLen; a++) {\n    if (chs[a] === node) {\n      return a;\n    }\n  }\n  return -1;\n}\n\n// Adds the node to the list of childNodes on the host and fakes any necessary\n// information such as parentNode.\nfunction registerNode (host, node, insertBefore, func) {\n  const index = indexOfNode(host, insertBefore);\n  eachNodeOrFragmentNodes(node, function (eachNode, eachIndex) {\n    func(eachNode, eachIndex);\n\n    if (canPatchNativeAccessors) {\n      nodeToParentNodeMap.set(eachNode, host);\n    } else {\n      staticProp(eachNode, 'parentNode', host);\n    }\n\n    if (index > -1) {\n      arrProto.splice.call(host.childNodes, index + eachIndex, 0, eachNode);\n    } else {\n      arrProto.push.call(host.childNodes, eachNode);\n    }\n  });\n}\n\n// Cleans up registerNode().\nfunction unregisterNode (host, node, func) {\n  const index = indexOfNode(host, node);\n\n  if (index > -1) {\n    func(node, 0);\n\n    if (canPatchNativeAccessors) {\n      nodeToParentNodeMap.set(node, null);\n    } else {\n      staticProp(node, 'parentNode', null);\n    }\n\n    arrProto.splice.call(host.childNodes, index, 1);\n  }\n}\n\nfunction addNodeToNode (host, node, insertBefore) {\n  registerNode(host, node, insertBefore, function (eachNode) {\n    host.__insertBefore(eachNode, insertBefore !== undefined ? insertBefore : null);\n  });\n}\n\nfunction addNodeToHost (host, node, insertBefore) {\n  registerNode(host, node, insertBefore, function (eachNode) {\n    const rootNode = hostToRootMap.get(host);\n    const slotNodes = rootToSlotMap.get(rootNode);\n    const slotNode = slotNodes[getSlotNameFromNode(eachNode)];\n    if (slotNode) {\n      slotNodeIntoSlot(slotNode, eachNode, insertBefore);\n    }\n  });\n}\n\nfunction addNodeToRoot (root, node, insertBefore) {\n  eachNodeOrFragmentNodes(node, function (node) {\n    if (isSlotNode(node)) {\n      addSlotToRoot(root, node);\n    } else {\n      const slotNodes = node.querySelectorAll && node.querySelectorAll('slot');\n      if (slotNodes) {\n        const slotNodesLen = slotNodes.length;\n        for (let a = 0; a < slotNodesLen; a++) {\n          addSlotToRoot(root, slotNodes[a]);\n        }\n      }\n    }\n  });\n  addNodeToNode(root, node, insertBefore);\n}\n\n// Adds a node to a slot. In other words, adds default content to a slot. It\n// ensures that if the slot doesn't have any assigned nodes yet, that the node\n// is actually displayed, otherwise it's just registered as child content.\nfunction addNodeToSlot (slot, node, insertBefore) {\n  const isInDefaultMode = slot.assignedNodes().length === 0;\n  registerNode(slot, node, insertBefore, function (eachNode) {\n    if (isInDefaultMode) {\n      slot.__insertBefore(eachNode, insertBefore !== undefined ? insertBefore : null);\n    }\n  });\n}\n\n// Removes a node from a slot (default content). It ensures that if the slot\n// doesn't have any assigned nodes yet, that the node is actually removed,\n// otherwise it's just unregistered.\nfunction removeNodeFromSlot (slot, node) {\n  const isInDefaultMode = slot.assignedNodes().length === 0;\n  unregisterNode(slot, node, function () {\n    if (isInDefaultMode) {\n      slot.__removeChild(node);\n    }\n  });\n}\n\nfunction addSlotToRoot (root, slot) {\n  const slotName = getSlotNameFromSlot(slot);\n\n  // Ensure a slot node's childNodes are overridden at the earliest point\n  // possible for WebKit.\n  if (!canPatchNativeAccessors && !slot.childNodes.push) {\n    staticProp(slot, 'childNodes', []);\n  }\n\n  rootToSlotMap.get(root)[slotName] = slot;\n  !slotToRootMap.has(slot) && slotToRootMap.set(slot, root);\n\n  eachChildNode(rootToHostMap.get(root), function (eachNode) {\n    if (!eachNode.assignedSlot && slotName === getSlotNameFromNode(eachNode)) {\n      slotNodeIntoSlot(slot, eachNode);\n    }\n  });\n}\n\nfunction removeNodeFromNode (host, node) {\n  unregisterNode(host, node, function () {\n    host.__removeChild(node);\n  });\n}\n\nfunction removeNodeFromHost (host, node) {\n  unregisterNode(host, node, function () {\n    slotNodeFromSlot(node);\n  });\n}\n\nfunction removeNodeFromRoot (root, node) {\n  unregisterNode(root, node, function () {\n    if (isSlotNode(node)) {\n      removeSlotFromRoot(root, node);\n    } else {\n      const nodes = node.querySelectorAll && node.querySelectorAll('slot');\n      if (nodes) {\n        for (let a = 0; a < nodes.length; a++) {\n          removeSlotFromRoot(root, nodes[a]);\n        }\n      }\n    }\n    root.__removeChild(node);\n  });\n}\n\nfunction removeSlotFromRoot (root, node) {\n  node.assignedNodes().forEach(slotNodeFromSlot);\n  delete rootToSlotMap.get(root)[getSlotNameFromSlot(node)];\n  slotToRootMap.delete(node);\n}\n\n// TODO terribly inefficient\nfunction getRootNode (host) {\n  if (isRootNode(host)) {\n    return host;\n  } else {\n    if (!host.parentNode) {\n      return;\n    }\n\n    return getRootNode(host.parentNode);\n  }\n}\n\nfunction appendChildOrInsertBefore (host, newNode, refNode) {\n  const nodeType = getNodeType(host);\n  const parentNode = newNode.parentNode;\n  const rootNode = getRootNode(host);\n\n  // Ensure childNodes is patched so we can manually update it for WebKit.\n  if (!canPatchNativeAccessors && !host.childNodes.push) {\n    staticProp(host, 'childNodes', [...host.childNodes]);\n  }\n\n  if (rootNode && getNodeType(newNode) === 'slot') {\n    addSlotToRoot(rootNode, newNode);\n  }\n\n  // If we append a child to a host, the host tells the shadow root to distribute\n  // it. If the root decides it doesn't need to be distributed, it is never\n  // removed from the old parent because in polyfill land we store a reference\n  // to the node but we don't move it. Due to that, we must explicitly remove the\n  // node from its old parent.\n  if (parentNode && getNodeType(parentNode) === 'host') {\n    if (canPatchNativeAccessors) {\n      nodeToParentNodeMap.set(newNode, null);\n    } else {\n      staticProp(newNode, 'parentNode', null);\n    }\n  }\n\n  if (nodeType === 'node') {\n    if (canPatchNativeAccessors) {\n      nodeToParentNodeMap.set(newNode, host);\n      return host.__insertBefore(newNode, refNode !== undefined ? refNode : null);\n    } else {\n      return addNodeToNode(host, newNode, refNode);\n    }\n  }\n\n  if (nodeType === 'slot') {\n    return addNodeToSlot(host, newNode, refNode);\n  }\n\n  if (nodeType === 'host') {\n    return addNodeToHost(host, newNode, refNode);\n  }\n\n  if (nodeType === 'root') {\n    return addNodeToRoot(host, newNode, refNode);\n  }\n}\n\nconst members = {\n  // For testing purposes.\n  ____assignedNodes: {\n    get () {\n      return this.______assignedNodes || (this.______assignedNodes = []);\n    }\n  },\n\n  // For testing purposes.\n  ____isInFallbackMode: {\n    get () {\n      return this.assignedNodes().length === 0;\n    }\n  },\n\n  ____slotChangeListeners: {\n    get () {\n      if (typeof this.______slotChangeListeners === 'undefined') {\n        this.______slotChangeListeners = 0;\n      }\n      return this.______slotChangeListeners;\n    },\n    set (value) {\n      this.______slotChangeListeners = value;\n    }\n  },\n  ____triggerSlotChangeEvent: {\n    value: debounce(function () {\n      if (this.____slotChangeListeners) {\n        this.dispatchEvent(new CustomEvent('slotchange', {\n          bubbles: false,\n          cancelable: false\n        }));\n      }\n    })\n  },\n  addEventListener: {\n    value (name, func, opts) {\n      if (name === 'slotchange' && isSlotNode(this)) {\n        this.____slotChangeListeners++;\n      }\n      return this.__addEventListener(name, func, opts);\n    }\n  },\n  appendChild: {\n    value (newNode) {\n      return appendChildOrInsertBefore(this, newNode);\n    }\n  },\n  assignedSlot: {\n    get () {\n      const slot = nodeToSlotMap.get(this);\n\n      if (!slot) return null;\n\n      const root = slotToRootMap.get(slot);\n      const host = rootToHostMap.get(root);\n      const mode = hostToModeMap.get(host);\n\n      return mode === 'open' ? slot : null;\n    }\n  },\n  attachShadow: {\n    value (opts) {\n      const mode = opts && opts.mode;\n      if (mode !== 'closed' && mode !== 'open') {\n        throw new Error('You must specify { mode } as \"open\" or \"closed\" to attachShadow().');\n      }\n\n      // Return the existing shadow root if it exists.\n      const existingShadowRoot = hostToRootMap.get(this);\n      if (existingShadowRoot) {\n        return existingShadowRoot;\n      }\n\n      const lightNodes = makeLikeNodeList([].slice.call(this.childNodes));\n      const shadowRoot = document.createElement(opts.polyfillShadowRootTagName || defaultShadowRootTagName);\n\n      // Host and shadow root data.\n      hostToModeMap.set(this, mode);\n      hostToRootMap.set(this, shadowRoot);\n      rootToHostMap.set(shadowRoot, this);\n      rootToSlotMap.set(shadowRoot, {});\n\n      if (canPatchNativeAccessors) {\n        nodeToChildNodesMap.set(this, lightNodes);\n      } else {\n        staticProp(this, 'childNodes', lightNodes);\n      }\n\n      // Process light DOM.\n      lightNodes.forEach(node => {\n        // Existing children should be removed from being displayed, but still\n        // appear to be child nodes. This is how light DOM works; they're still\n        // child nodes but not in the composed DOM yet as there won't be any\n        // slots for them to go into.\n        this.__removeChild(node);\n\n        // We must register the parentNode here as this has the potential to\n        // become out of sync if the node is moved before being slotted.\n        if (canPatchNativeAccessors) {\n          nodeToParentNodeMap.set(node, this);\n        } else {\n          staticProp(node, 'parentNode', this);\n        }\n      });\n\n      // The shadow root is actually the only child of the host.\n      return this.__appendChild(shadowRoot);\n    }\n  },\n  childElementCount: {\n    get () {\n      return this.children.length;\n    }\n  },\n  childNodes: {\n    get () {\n      if (canPatchNativeAccessors && getNodeType(this) === 'node') {\n        return this.__childNodes;\n      }\n      let childNodes = nodeToChildNodesMap.get(this);\n      childNodes || nodeToChildNodesMap.set(this, childNodes = makeLikeNodeList([]));\n      return childNodes;\n    }\n  },\n  children: {\n    get () {\n      const chs = [];\n      eachChildNode(this, function (node) {\n        if (node.nodeType === 1) {\n          chs.push(node);\n        }\n      });\n      return makeLikeNodeList(chs);\n    }\n  },\n  firstChild: {\n    get () {\n      return this.childNodes[0] || null;\n    }\n  },\n  firstElementChild: {\n    get () {\n      return this.children[0] || null;\n    }\n  },\n  assignedNodes: {\n    value () {\n      if (isSlotNode(this)) {\n        let assigned = assignedToSlotMap.get(this);\n        assigned || assignedToSlotMap.set(this, assigned = []);\n        return assigned;\n      }\n    }\n  },\n  hasChildNodes: {\n    value () {\n      return this.childNodes.length > 0;\n    }\n  },\n  innerHTML: {\n    get () {\n      let innerHTML = '';\n\n      const getHtmlNodeOuterHtml = (node) => node.outerHTML;\n      const getOuterHtmlByNodeType = {\n        1: getHtmlNodeOuterHtml,\n        3: getEscapedTextContent,\n        8: getCommentNodeOuterHtml\n      };\n\n      eachChildNode(this, function (node) {\n        const getOuterHtml = getOuterHtmlByNodeType[node.nodeType] || getHtmlNodeOuterHtml;\n        innerHTML += getOuterHtml(node);\n      });\n      return innerHTML;\n    },\n    set (innerHTML) {\n      const parsed = parse(innerHTML);\n\n      while (this.hasChildNodes()) {\n        this.removeChild(this.firstChild);\n      }\n\n      while (parsed.hasChildNodes()) {\n        const firstChild = parsed.firstChild;\n\n        // When we polyfill everything on HTMLElement.prototype, we overwrite\n        // properties. This makes it so that parentNode reports null even though\n        // it's actually a parent of the HTML parser. For this reason,\n        // cleanNode() won't work and we must manually remove it from the\n        // parser before it is moved to the host just in case it's added as a\n        // light node but not assigned to a slot.\n        parsed.removeChild(firstChild);\n\n        this.appendChild(firstChild);\n      }\n    }\n  },\n  insertBefore: {\n    value (newNode, refNode) {\n      return appendChildOrInsertBefore(this, newNode, refNode);\n    }\n  },\n  lastChild: {\n    get () {\n      const ch = this.childNodes;\n      return ch[ch.length - 1] || null;\n    }\n  },\n  lastElementChild: {\n    get () {\n      const ch = this.children;\n      return ch[ch.length - 1] || null;\n    }\n  },\n  name: {\n    get () {\n      return this.getAttribute('name');\n    },\n    set (name) {\n      return this.setAttribute('name', name);\n    }\n  },\n  nextSibling: {\n    get () {\n      const host = this;\n      return eachChildNode(this.parentNode, function (child, index, nodes) {\n        if (host === child) {\n          return nodes[index + 1] || null;\n        }\n      });\n    }\n  },\n  nextElementSibling: {\n    get () {\n      const host = this;\n      let found;\n      return eachChildNode(this.parentNode, function (child) {\n        if (found && child.nodeType === 1) {\n          return child;\n        }\n        if (host === child) {\n          found = true;\n        }\n      });\n    }\n  },\n  outerHTML: {\n    get () {\n      const name = this.tagName.toLowerCase();\n      const attributes = Array.prototype.slice.call(this.attributes).map(function (attr) {\n        return ` ${attr.name}${attr.value ? `=\"${attr.value}\"` : ''}`;\n      }).join('');\n      return `<${name}${attributes}>${this.innerHTML}</${name}>`;\n    },\n\n    set (outerHTML) {\n      if (this.parentNode) {\n        const parsed = parse(outerHTML);\n        this.parentNode.replaceChild(parsed.firstChild, this);\n      } else {\n        if (canPatchNativeAccessors) {\n          this.__outerHTML = outerHTML;  // this will throw a native error;\n        } else {\n          throw new Error('Failed to set the \\'outerHTML\\' property on \\'Element\\': This element has no parent node.');\n        }\n      }\n    }\n  },\n  parentElement: {\n    get () {\n      return findClosest(this.parentNode, function (node) {\n        return node.nodeType === 1;\n      });\n    }\n  },\n  parentNode: {\n    get () {\n      return nodeToParentNodeMap.get(this) || this.__parentNode || null;\n    }\n  },\n  previousSibling: {\n    get () {\n      const host = this;\n      return eachChildNode(this.parentNode, function (child, index, nodes) {\n        if (host === child) {\n          return nodes[index - 1] || null;\n        }\n      });\n    }\n  },\n  previousElementSibling: {\n    get () {\n      const host = this;\n      let found;\n      return eachChildNode(this.parentNode, function (child) {\n        if (found && host === child) {\n          return found;\n        }\n        if (child.nodeType === 1) {\n          found = child;\n        }\n      });\n    }\n  },\n  removeChild: {\n    value (refNode) {\n      const nodeType = getNodeType(this);\n\n      if (nodeType === 'node') {\n        if (canPatchNativeAccessors) {\n          return this.__removeChild(refNode);\n        } else {\n          return removeNodeFromNode(this, refNode);\n        }\n      }\n\n      if (nodeType === 'slot') {\n        return removeNodeFromSlot(this, refNode);\n      }\n\n      if (nodeType === 'host') {\n        return removeNodeFromHost(this, refNode);\n      }\n\n      if (nodeType === 'root') {\n        return removeNodeFromRoot(this, refNode);\n      }\n    }\n  },\n  removeEventListener: {\n    value (name, func, opts) {\n      if (name === 'slotchange' && this.____slotChangeListeners && isSlotNode(this)) {\n        this.____slotChangeListeners--;\n      }\n      return this.__removeEventListener(name, func, opts);\n    }\n  },\n  replaceChild: {\n    value (newNode, refNode) {\n      this.insertBefore(newNode, refNode);\n      return this.removeChild(refNode);\n    }\n  },\n  shadowRoot: {\n    get () {\n      return hostToModeMap.get(this) === 'open' ? hostToRootMap.get(this) : null;\n    }\n  },\n  textContent: {\n    get () {\n      let textContent = '';\n      eachChildNode(this, function (node) {\n        if (node.nodeType !== Node.COMMENT_NODE) {\n          textContent += node.textContent;\n        }\n      });\n      return textContent;\n    },\n    set (textContent) {\n      while (this.hasChildNodes()) {\n        this.removeChild(this.firstChild);\n      }\n      if (!textContent) {\n        return;\n      }\n      this.appendChild(document.createTextNode(textContent));\n    }\n  }\n};\n\nif (!('attachShadow' in document.createElement('div'))) {\n  const elementProto = HTMLElement.prototype;\n  const textProto = Text.prototype;\n  const commProto = Comment.prototype;\n  const textNode = document.createTextNode('');\n  const commNode = document.createComment('');\n\n  Object.keys(members).forEach(function (memberName) {\n    const memberProperty = members[memberName];\n\n    // All properties should be configurable.\n    memberProperty.configurable = true;\n\n    // Applying to the data properties only since we can't have writable accessor properties.\n    if (memberProperty.hasOwnProperty('value')) {\n      memberProperty.writable = true;\n    }\n\n    // Polyfill as much as we can and work around WebKit in other areas.\n    if (canPatchNativeAccessors || polyfillAtRuntime.indexOf(memberName) === -1) {\n      const nativeDescriptor = getPropertyDescriptor(elementProto, memberName);\n      const nativeTextDescriptor = getPropertyDescriptor(textProto, memberName);\n      const nativeCommDescriptor = getPropertyDescriptor(commProto, memberName);\n      \n      const shouldOverrideInTextNode = (memberName in textNode && doNotOverridePropertiesInTextNodes.indexOf(memberName) === -1) || ~defineInTextNodes.indexOf(memberName);\n      const shouldOverrideInCommentNode = (memberName in commNode && doNotOverridePropertiesInCommNodes.indexOf(memberName) === -1) || ~defineInCommNodes.indexOf(memberName);\n\n      Object.defineProperty(elementProto, memberName, memberProperty);\n\n      if (nativeDescriptor) {\n        Object.defineProperty(elementProto, '__' + memberName, nativeDescriptor);\n      }\n\n      if (shouldOverrideInTextNode) {\n        Object.defineProperty(textProto, memberName, memberProperty);\n      }\n\n      if (shouldOverrideInTextNode && nativeTextDescriptor) {\n        Object.defineProperty(textProto, '__' + memberName, nativeTextDescriptor);\n      }\n\n      if (shouldOverrideInCommentNode) {\n        Object.defineProperty(commProto, memberName, memberProperty);\n      }\n\n      if (shouldOverrideInCommentNode && nativeCommDescriptor) {\n        Object.defineProperty(commProto, '__' + memberName, nativeCommDescriptor);\n      }\n    }\n  });\n}\n\nexport default version;\n"],"names":["eachChildNode","node","func","chs","childNodes","chsLen","length","a","ret","eachNodeOrFragmentNodes","DocumentFragment","getPrototype","obj","key","descriptor","Object","getOwnPropertyDescriptor","getPrototypeOf","Node","div","proto","getter","get","setter","set","_descriptor","value","getEscapedTextContent","textNode","textContent","replace","getCommentNodeOuterHtml","commentNode","text","parse","html","tree","document","createElement","canPatchNativeAccessors","__innerHTML","parsed","parser","parseFromString","body","firstChild","hasChildNodes","removeChild","appendChild","importNode","staticProp","name","defineProperty","arrayItem","idx","this","makeLikeNodeList","arr","item","getNodeType","isHostNode","isSlotNode","isRootNode","hostToRootMap","tagName","defaultShadowRootTagNameUc","findClosest","parentNode","getSlotNameFromSlot","getAttribute","getSlotNameFromNode","slotNodeIntoSlot","slot","insertBefore","nodeType","trim","slottedNodeTypes","indexOf","assignedNodes","shouldGoIntoContentMode","slotInsertBeforeIndex","call","__removeChild","__insertBefore","undefined","splice","__appendChild","push","____triggerSlotChangeEvent","slotNodeFromSlot","assignedSlot","index","shouldGoIntoDefaultMode","indexOfNode","host","registerNode","eachNode","eachIndex","unregisterNode","addNodeToNode","addNodeToHost","rootNode","slotNodes","rootToSlotMap","slotNode","addNodeToRoot","root","querySelectorAll","slotNodesLen","addNodeToSlot","isInDefaultMode","removeNodeFromSlot","addSlotToRoot","slotName","slotToRootMap","has","rootToHostMap","removeNodeFromNode","removeNodeFromHost","removeNodeFromRoot","nodes","removeSlotFromRoot","forEach","getRootNode","appendChildOrInsertBefore","newNode","refNode","nativeParentNode","getPropertyDescriptor","Element","prototype","now","Date","getTime","module","exports","require$$0","wait","immediate","later","last","timestamp","setTimeout","apply","context","args","timeout","result","arguments","callNow","global","undefined_","define","object","nameOf","defProp","configurable","writable","toSource","match","funcName","createStorage","creator","storage","weakmap","WM","defaultCreator","getProps","getOwnPropertyNames","Function","toString","create","hasOwn","hasOwnProperty","Data","puid","createUID","secret","unlock","store","data","dataDesc","datalock","uids","Math","random","slice","globalID","isExtensible","TypeError","props","o","v","WeakMap","iterable","unwrap","delete_","had","validate","wrap","collection","initialize","i","Array","src","del","e","split","stringifier","prep","__proto__","f","method","eval","ce","window","CustomEvent","preventDefault","defaultPrevented","Error","event","params","evt","createEvent","initCustomEvent","bubbles","cancelable","detail","origPrevent","Event","arrProto","defaultShadowRootTagName","toUpperCase","polyfillAtRuntime","doNotOverridePropertiesInTextNodes","defineInTextNodes","doNotOverridePropertiesInCommNodes","defineInCommNodes","ELEMENT_NODE","TEXT_NODE","assignedToSlotMap","hostToModeMap","nodeToChildNodesMap","nodeToParentNodeMap","nodeToSlotMap","DOMParser","members","______assignedNodes","______slotChangeListeners","debounce","____slotChangeListeners","dispatchEvent","opts","__addEventListener","mode","existingShadowRoot","lightNodes","shadowRoot","polyfillShadowRootTagName","children","__childNodes","assigned","innerHTML","getHtmlNodeOuterHtml","outerHTML","getOuterHtmlByNodeType","getOuterHtml","ch","setAttribute","child","found","toLowerCase","attributes","map","attr","join","replaceChild","__outerHTML","__parentNode","__removeEventListener","COMMENT_NODE","createTextNode","elementProto","HTMLElement","textProto","Text","commProto","Comment","commNode","createComment","keys","memberName","memberProperty","nativeDescriptor","nativeTextDescriptor","nativeCommDescriptor","shouldOverrideInTextNode","shouldOverrideInCommentNode"],"mappings":"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"}