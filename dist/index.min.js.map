{"version":3,"sources":["index.min.js"],"names":["global","factory","exports","module","define","amd","skatejsNamedSlots","this","__commonjs","fn","eachChildNode","node","func","chs","childNodes","chsLen","length","a","ret","eachNodeOrFragmentNodes","DocumentFragment","convertXmlToHtml","nodeType","copy","document","createElement","tagName","attributes","attr","setAttribute","name","value","childNode","appendChild","parse","html","tree","parsed","parser","parseFromString","hasChildNodes","firstChild","removeChild","staticProp","obj","Object","defineProperty","configurable","get","arrayItem","idx","makeLikeNodeList","arr","item","getNodeType","isHostNode","isSlotNode","isRootNode","hostToRootMap","defaultShadowRootTagNameUc","findClosest","parentNode","getSlotNameFromSlot","getAttribute","getSlotNameFromNode","slotNodeIntoSlot","slot","insertBefore","assignedNodes","getAssignedNodes","slotInsertBeforeIndex","indexOf","textContent","trim","nodeToSlotMap","set","slotToModeMap","slice","call","forEach","fallbackNode","__removeChild","shouldAffectSlot","__insertBefore","splice","__appendChild","push","____triggerSlotChangeEvent","slotNodeFromSlot","assignedSlot","index","indexOfNode","host","registerNode","eachNode","eachIndex","canPatchNativeAccessors","nodeToParentNodeMap","unregisterNode","addNodeToNode","addNodeToHost","rootNode","slotNodes","rootToSlotMap","slotNode","addNodeToRoot","root","addSlotToRoot","querySelectorAll","slotNodesLen","slotName","rootToHostMap","removeNodeFromNode","removeNodeFromHost","removeNodeFromRoot","removeSlotFromRoot","nodes","appendChildOrInsertBefore","newNode","refNode","findDescriptorFor","protos","ctor","window","proto","prototype","hasOwnProperty","getOwnPropertyDescriptor","Node","index$1","now","Date","getTime","require$$0","wait","immediate","later","last","timestamp","timeout","setTimeout","result","apply","context","args","arguments","callNow","debounce","version","WeakMap","Wm","key","delete","has","val","enumerable","defaultShadowRootTagName","toUpperCase","polyfilAtRuntime","assignedToSlotMap","hostToModeMap","nodeToChildNodesMap","DOMParser","members","____assignedNodes","______assignedNodes","____isInFallbackMode","____slotChangeListeners","______slotChangeListeners","dispatchEvent","CustomEvent","bubbles","cancelable","addEventListener","opts","__addEventListener","attachShadow","_this","mode","Error","existingShadowRoot","lightNodes","shadowRoot","polyfillShadowRootTagName","childElementCount","children","__childNodes","firstElementChild","assigned","innerHTML","outerHTML","lastChild","ch","lastElementChild","nextSibling","child","nextElementSibling","found","undefined","toLowerCase","Array","map","join","parentElement","__parentNode","previousSibling","previousElementSibling","removeEventListener","__removeEventListener","replaceChild","createTextNode","elementProto","HTMLElement","keys","memberName","memberProperty","nativeDescriptor","api","freeze","default","previousGlobal","noConflict"],"mappings":"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","file":"index.min.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global.skatejsNamedSlots = factory());\n}(this, function () {\n\n    function __commonjs(fn, module) { return module = { exports: {} }, fn(module, module.exports), module.exports; }\n\n    function eachChildNode(node, func) {\n      if (!node) {\n        return;\n      }\n\n      var chs = node.childNodes;\n      var chsLen = chs.length;\n      for (var a = 0; a < chsLen; a++) {\n        var ret = func(chs[a], a, chs);\n        if (typeof ret !== 'undefined') {\n          return ret;\n        }\n      }\n    }\n\n    function eachNodeOrFragmentNodes(node, func) {\n      if (node instanceof DocumentFragment) {\n        var chs = node.childNodes;\n        var chsLen = chs.length;\n        for (var a = 0; a < chsLen; a++) {\n          func(chs[a], a);\n        }\n      } else {\n        func(node, 0);\n      }\n    }\n\n    // Any code referring to this is because it has to work around this bug in\n    // WebKit: https://bugs.webkit.org/show_bug.cgi?id=49739\n    var canPatchNativeAccessors = !!Object.getOwnPropertyDescriptor(window.Node.prototype, 'parentNode').get;\n\n    var index$1 = __commonjs(function (module) {\n    module.exports = Date.now || now;\n\n    function now() {\n        return new Date().getTime();\n    }\n    });\n\n    var require$$0 = (index$1 && typeof index$1 === 'object' && 'default' in index$1 ? index$1['default'] : index$1);\n\n    var index = __commonjs(function (module) {\n    /**\n     * Module dependencies.\n     */\n\n    var now = require$$0;\n\n    /**\n     * Returns a function, that, as long as it continues to be invoked, will not\n     * be triggered. The function will be called after it stops being called for\n     * N milliseconds. If `immediate` is passed, trigger the function on the\n     * leading edge, instead of the trailing.\n     *\n     * @source underscore.js\n     * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n     * @param {Function} function to wrap\n     * @param {Number} timeout in ms (`100`)\n     * @param {Boolean} whether to execute at the beginning (`false`)\n     * @api public\n     */\n\n    module.exports = function debounce(func, wait, immediate) {\n      var timeout, args, context, timestamp, result;\n      if (null == wait) wait = 100;\n\n      function later() {\n        var last = now() - timestamp;\n\n        if (last < wait && last > 0) {\n          timeout = setTimeout(later, wait - last);\n        } else {\n          timeout = null;\n          if (!immediate) {\n            result = func.apply(context, args);\n            if (!timeout) context = args = null;\n          }\n        }\n      };\n\n      return function debounced() {\n        context = this;\n        args = arguments;\n        timestamp = now();\n        var callNow = immediate && !timeout;\n        if (!timeout) timeout = setTimeout(later, wait);\n        if (callNow) {\n          result = func.apply(context, args);\n          context = args = null;\n        }\n\n        return result;\n      };\n    };\n    });\n\n    var debounce = (index && typeof index === 'object' && 'default' in index ? index['default'] : index);\n\n    var version = '0.0.1';\n\n    var WeakMap = window.WeakMap || function () {\n      var index = 0;\n      function Wm() {\n        this.key = '____weak_map_' + index++;\n      }\n      Wm.prototype = {\n        delete: function _delete(obj) {\n          if (obj) {\n            delete obj[this.key];\n          }\n        },\n        get: function get(obj) {\n          return obj ? obj[this.key] : null;\n        },\n        has: function has(obj) {\n          return obj ? typeof obj[this.key] !== 'undefined' : false;\n        },\n        set: function set(obj, val) {\n          if (obj) {\n            var key = this.key;\n            if (typeof obj[key] === 'undefined') {\n              Object.defineProperty(obj, key, {\n                configurable: true,\n                enumerable: false,\n                value: val\n              });\n            } else {\n              obj[key] = val;\n            }\n          }\n        }\n      };\n      return Wm;\n    }();\n\n    // We use a real DOM node for a shadow root. This is because the host node\n    // basically becomes a virtual entry point for your element leaving the shadow\n    // root the only thing that can receive instructions on how the host should\n    // render to the browser.\n    var defaultShadowRootTagName = '_shadow_root_';\n    var defaultShadowRootTagNameUc = defaultShadowRootTagName.toUpperCase();\n\n    // * WebKit only *\n    //\n    // These members we need cannot override as we require native access to their\n    // original values at some point.\n    var polyfilAtRuntime = ['childNodes', 'parentNode'];\n\n    // These are the protos that we need to search for native descriptors on.\n    var protos = ['Node', 'Element', 'EventTarget'];\n\n    // Private data stores.\n    var assignedToSlotMap = new WeakMap();\n    var hostToModeMap = new WeakMap();\n    var hostToRootMap = new WeakMap();\n    var nodeToChildNodesMap = new WeakMap();\n    var nodeToParentNodeMap = new WeakMap();\n    var nodeToSlotMap = new WeakMap();\n    var rootToHostMap = new WeakMap();\n    var rootToSlotMap = new WeakMap();\n    var slotToModeMap = new WeakMap();\n\n    // * WebKit only *\n    //\n    // We require some way to parse HTML natively because we can't use the native\n    // accessors. To do this we parse as XML and conver each node in the tree to\n    // HTML nodes.\n    //\n    // This works because we polyfill at the HTMLElement level and XML nodes are\n    // considered Element nodes and we don't polyfill at that level.\n\n    var parser = new DOMParser();\n\n    function convertXmlToHtml(node) {\n      var nodeType = node.nodeType;\n\n      if (nodeType === 1) {\n        var copy = document.createElement(node.tagName);\n        for (var a = 0; a < node.attributes.length; a++) {\n          var attr = node.attributes[a];\n          copy.setAttribute(attr.name, attr.value);\n        }\n        for (var a = 0; a < node.childNodes.length; a++) {\n          var childNode = node.childNodes[a];\n          copy.appendChild(convertXmlToHtml(childNode));\n        }\n        return copy;\n      }\n      return node;\n    }\n\n    function parse(html) {\n      var tree = document.createElement('div');\n      var parsed = parser.parseFromString(html, 'text/xml');\n      while (parsed.hasChildNodes()) {\n        var firstChild = parsed.firstChild;\n        parsed.removeChild(firstChild);\n        tree.appendChild(convertXmlToHtml(firstChild));\n      }\n      return tree;\n    }\n\n    function staticProp(obj, name, value) {\n      Object.defineProperty(obj, name, {\n        configurable: true,\n        get: function get() {\n          return value;\n        }\n      });\n    }\n\n    // Slotting helpers.\n\n    function arrayItem(idx) {\n      return this[idx];\n    }\n\n    function makeLikeNodeList(arr) {\n      arr.item = arrayItem;\n      return arr;\n    }\n\n    function getNodeType(node) {\n      if (isHostNode(node)) {\n        return 'host';\n      }\n\n      if (isSlotNode(node)) {\n        return 'slot';\n      }\n\n      if (isRootNode(node)) {\n        return 'root';\n      }\n\n      return 'node';\n    }\n\n    function isHostNode(node) {\n      return !!hostToRootMap.get(node);\n    }\n\n    function isSlotNode(node) {\n      return node.tagName === 'SLOT';\n    }\n\n    function isRootNode(node) {\n      return node.tagName === defaultShadowRootTagNameUc;\n    }\n\n    function findClosest(node, func) {\n      while (node) {\n        if (node === document) {\n          break;\n        }\n        if (func(node)) {\n          return node;\n        }\n        node = node.parentNode;\n      }\n    }\n\n    function getSlotNameFromSlot(node) {\n      return node.getAttribute && node.getAttribute('name') || 'default';\n    }\n\n    function getSlotNameFromNode(node) {\n      return node.getAttribute && node.getAttribute('slot') || 'default';\n    }\n\n    function slotNodeIntoSlot(slot, node, insertBefore) {\n      var assignedNodes = slot.getAssignedNodes();\n      var slotInsertBeforeIndex = assignedNodes.indexOf(insertBefore);\n\n      // Don't slot nodes that have content but are only whitespace. This is an\n      // anomaly that I don't think the spec deals with.\n      //\n      // The problem is:\n      //\n      // - If you insert HTML with indentation into the page, there will be\n      //   whitespace and if that's inserted it messes with fallback content\n      //   calculation where there is formatting, but no meaningful content, so in\n      //   theory it should fallback. Since you can attach a shadow root after we\n      //   mean to insert an empty text node and have it \"count\", we can't really\n      //   discard nodes that are considered formatting at the time of attachment.\n      // - You can insert a text node and modify its text content later.\n      //   Incremental DOM seems to do this. Every way I look at it, it seems\n      //   problematic that we should have to screen for content, but I don't seems\n      //   much of a way around it at the moment.\n      if (node.nodeType === 3 && node.textContent && node.textContent.trim().length === 0) {\n        return;\n      }\n\n      nodeToSlotMap.set(node, slot);\n\n      // If there's currently no assigned nodes, there will be, so remove all fallback content.\n      if (!assignedNodes.length) {\n        slotToModeMap.set(slot, false);\n        [].slice.call(slot.childNodes).forEach(function (fallbackNode) {\n          return slot.__removeChild(fallbackNode);\n        });\n      }\n\n      var shouldAffectSlot = !slotToModeMap.get(slot);\n\n      if (slotInsertBeforeIndex > -1) {\n        if (shouldAffectSlot) {\n          slot.__insertBefore(node, insertBefore);\n        }\n\n        assignedNodes.splice(slotInsertBeforeIndex, 0, node);\n      } else {\n        if (shouldAffectSlot) {\n          slot.__appendChild(node);\n        }\n\n        assignedNodes.push(node);\n      }\n\n      slot.____triggerSlotChangeEvent();\n    }\n\n    function slotNodeFromSlot(node) {\n      var slot = node.assignedSlot;\n\n      if (slot) {\n        var assignedNodes = slot.getAssignedNodes();\n        var index = assignedNodes.indexOf(node);\n\n        if (index > -1) {\n          assignedNodes.splice(index, 1);\n          nodeToSlotMap.set(node, null);\n\n          var shouldAffectSlot = !slotToModeMap.get(slot);\n\n          // We only update the actual DOM representation if we're displaying\n          // slotted nodes.\n          if (shouldAffectSlot) {\n            slot.__removeChild(node);\n          }\n\n          // If this was the last slotted node, then insert fallback content.\n          if (!assignedNodes.length) {\n            slotToModeMap.set(slot, true);\n            eachChildNode(slot, function (node) {\n              slot.__appendChild(node);\n            });\n          }\n\n          slot.____triggerSlotChangeEvent();\n        }\n      }\n    }\n\n    function indexOfNode(host, node) {\n      var chs = host.childNodes;\n      var chsLen = chs.length;\n      for (var a = 0; a < chsLen; a++) {\n        if (chs[a] === node) {\n          return a;\n        }\n      }\n      return -1;\n    }\n\n    // Adds the node to the list of childNodes on the host and fakes any necessary\n    // information such as parentNode.\n    function registerNode(host, node, insertBefore, func) {\n      var index = indexOfNode(host, insertBefore);\n      eachNodeOrFragmentNodes(node, function (eachNode, eachIndex) {\n        func(eachNode, eachIndex);\n\n        if (canPatchNativeAccessors) {\n          nodeToParentNodeMap.set(eachNode, host);\n        } else {\n          staticProp(eachNode, 'parentNode', host);\n        }\n\n        if (index > -1) {\n          host.childNodes.splice(index + eachIndex, 0, eachNode);\n        } else {\n          host.childNodes.push(eachNode);\n        }\n      });\n    }\n\n    // Cleans up registerNode().\n    function unregisterNode(host, node, func) {\n      var index = indexOfNode(host, node);\n      if (index > -1) {\n        func(node, 0);\n\n        if (canPatchNativeAccessors) {\n          nodeToParentNodeMap.set(node, null);\n        } else {\n          staticProp(node, 'parentNode', null);\n        }\n\n        host.childNodes.splice(index, 1);\n      }\n    }\n\n    function addNodeToNode(host, node, insertBefore) {\n      registerNode(host, node, insertBefore, function (eachNode) {\n        host.__insertBefore(eachNode, insertBefore);\n      });\n    }\n\n    function addNodeToHost(host, node, insertBefore) {\n      registerNode(host, node, insertBefore, function (eachNode) {\n        var rootNode = hostToRootMap.get(host);\n        var slotNodes = rootToSlotMap.get(rootNode);\n        var slotNode = slotNodes[getSlotNameFromNode(eachNode)];\n        if (slotNode) {\n          slotNodeIntoSlot(slotNode, eachNode, insertBefore);\n        }\n      });\n    }\n\n    function addNodeToRoot(root, node, insertBefore) {\n      eachNodeOrFragmentNodes(node, function (node) {\n        if (isSlotNode(node)) {\n          addSlotToRoot(root, node);\n        } else {\n          var slotNodes = node.querySelectorAll && node.querySelectorAll('slot');\n          if (slotNodes) {\n            var slotNodesLen = slotNodes.length;\n            for (var a = 0; a < slotNodesLen; a++) {\n              addSlotToRoot(root, slotNodes[a]);\n            }\n          }\n        }\n      });\n      addNodeToNode(root, node, insertBefore);\n    }\n\n    function addSlotToRoot(root, node) {\n      var slotName = getSlotNameFromSlot(node);\n      slotToModeMap.set(node, true);\n      rootToSlotMap.get(root)[slotName] = node;\n      eachChildNode(rootToHostMap.get(root), function (eachNode) {\n        if (!eachNode.assignedSlot && slotName === getSlotNameFromNode(eachNode)) {\n          slotNodeIntoSlot(node, eachNode);\n        }\n      });\n    }\n\n    function removeNodeFromNode(host, node) {\n      unregisterNode(host, node, function () {\n        host.__removeChild(node);\n      });\n    }\n\n    function removeNodeFromHost(host, node) {\n      unregisterNode(host, node, function () {\n        slotNodeFromSlot(node);\n      });\n    }\n\n    function removeNodeFromRoot(root, node) {\n      unregisterNode(root, node, function () {\n        if (isSlotNode(node)) {\n          removeSlotFromRoot(root, node);\n        } else {\n          var nodes = node.querySelectorAll && node.querySelectorAll('slot');\n          for (var a = 0; a < nodes.length; a++) {\n            removeSlotFromRoot(root, nodes[a]);\n          }\n        }\n      });\n    }\n\n    function removeSlotFromRoot(root, node) {\n      node.getAssignedNodes().forEach(slotNodeFromSlot);\n      delete rootToSlotMap.get(root)[getSlotNameFromSlot(node)];\n    }\n\n    function appendChildOrInsertBefore(host, newNode, refNode) {\n      var nodeType = getNodeType(host);\n      var parentNode = newNode.parentNode;\n\n      if (!canPatchNativeAccessors && !host.childNodes.push) {\n        staticProp(host, 'childNodes', []);\n      }\n\n      // If we append a child to a host, the host tells the shadow root to distribute\n      // it. If the root decides it doesn't need to be distributed, it is never\n      // removed from the old parent because in polyfill land we store a reference\n      // to the node but we don't move it. Due to that, we must explicitly remove the\n      // node from its old parent.\n      if (parentNode && getNodeType(parentNode) === 'host') {\n        if (canPatchNativeAccessors) {\n          nodeToParentNodeMap.set(newNode, null);\n        } else {\n          staticProp(newNode, 'parentNode', null);\n        }\n      }\n\n      if (nodeType === 'node') {\n        if (canPatchNativeAccessors) {\n          return host.__insertBefore(newNode, refNode);\n        } else {\n          return addNodeToNode(host, newNode, refNode);\n        }\n      }\n\n      if (nodeType === 'slot') {\n        return addNodeToNode(host, newNode, refNode);\n      }\n\n      if (nodeType === 'host') {\n        return addNodeToHost(host, newNode, refNode);\n      }\n\n      if (nodeType === 'root') {\n        return addNodeToRoot(host, newNode, refNode);\n      }\n    }\n\n    var members = {\n      // For testing purposes.\n      ____assignedNodes: {\n        get: function get() {\n          return this.______assignedNodes || (this.______assignedNodes = []);\n        }\n      },\n\n      // For testing purposes.\n      ____isInFallbackMode: {\n        get: function get() {\n          return slotToModeMap.get(this);\n        }\n      },\n\n      ____slotChangeListeners: {\n        get: function get() {\n          if (typeof this.______slotChangeListeners === 'undefined') {\n            this.______slotChangeListeners = 0;\n          }\n          return this.______slotChangeListeners;\n        },\n        set: function set(value) {\n          this.______slotChangeListeners = value;\n        }\n      },\n      ____triggerSlotChangeEvent: {\n        value: debounce(function () {\n          if (this.____slotChangeListeners) {\n            this.dispatchEvent(new CustomEvent('slotchange', {\n              bubbles: false,\n              cancelable: false\n            }));\n          }\n        })\n      },\n      addEventListener: {\n        value: function value(name, func, opts) {\n          if (name === 'slotchange' && isSlotNode(this)) {\n            this.____slotChangeListeners++;\n          }\n          return this.__addEventListener(name, func, opts);\n        }\n      },\n      appendChild: {\n        value: function value(newNode) {\n          return appendChildOrInsertBefore(this, newNode);\n        }\n      },\n      assignedSlot: {\n        get: function get() {\n          return nodeToSlotMap.get(this) || null;\n        }\n      },\n      attachShadow: {\n        value: function value(opts) {\n          var _this = this;\n\n          var mode = opts && opts.mode;\n          if (mode !== 'closed' && mode !== 'open') {\n            throw new Error('You must specify { mode } as \"open\" or \"closed\" to attachShadow().');\n          }\n\n          // Return the existing shadow root if it exists.\n          var existingShadowRoot = hostToRootMap.get(this);\n          if (existingShadowRoot) {\n            return existingShadowRoot;\n          }\n\n          var lightNodes = makeLikeNodeList([].slice.call(this.childNodes));\n          var shadowRoot = document.createElement(opts.polyfillShadowRootTagName || defaultShadowRootTagName);\n\n          // Host and shadow root data.\n          hostToModeMap.set(this, mode);\n          hostToRootMap.set(this, shadowRoot);\n          rootToHostMap.set(shadowRoot, this);\n          rootToSlotMap.set(shadowRoot, {});\n\n          if (canPatchNativeAccessors) {\n            nodeToChildNodesMap.set(this, lightNodes);\n          } else {\n            staticProp(this, 'childNodes', lightNodes);\n          }\n\n          // Existing children should be removed from being displayed, but still\n          // appear to be child nodes. This is how light DOM works; they're still\n          // child nodes but not in the composed DOM yet as there won't be any\n          // slots for them to go into.\n          eachChildNode(this, function (node) {\n            return _this.__removeChild(node);\n          });\n\n          // The shadow root is actually the only child of the host.\n          return this.__appendChild(shadowRoot);\n        }\n      },\n      childElementCount: {\n        get: function get() {\n          return this.children.length;\n        }\n      },\n      childNodes: {\n        get: function get() {\n          if (canPatchNativeAccessors && getNodeType(this) === 'node') {\n            return this.__childNodes;\n          }\n          var childNodes = nodeToChildNodesMap.get(this);\n          childNodes || nodeToChildNodesMap.set(this, childNodes = makeLikeNodeList([]));\n          return childNodes;\n        }\n      },\n      children: {\n        get: function get() {\n          var chs = [];\n          eachChildNode(this, function (node) {\n            if (node.nodeType === 1) {\n              chs.push(node);\n            }\n          });\n          return makeLikeNodeList(chs);\n        }\n      },\n      firstChild: {\n        get: function get() {\n          return this.childNodes[0] || null;\n        }\n      },\n      firstElementChild: {\n        get: function get() {\n          return this.children[0] || null;\n        }\n      },\n      getAssignedNodes: {\n        value: function value() {\n          if (isSlotNode(this)) {\n            var assigned = assignedToSlotMap.get(this);\n            assigned || assignedToSlotMap.set(this, assigned = []);\n            return assigned;\n          }\n        }\n      },\n      hasChildNodes: {\n        value: function value() {\n          return this.childNodes.length > 0;\n        }\n      },\n      innerHTML: {\n        get: function get() {\n          var innerHTML = '';\n          eachChildNode(this, function (node) {\n            innerHTML += node.nodeType === 1 ? node.outerHTML : node.textContent;\n          });\n          return innerHTML;\n        },\n        set: function set(innerHTML) {\n          var parsed = parse(innerHTML);\n\n          while (this.hasChildNodes()) {\n            this.removeChild(this.firstChild);\n          }\n\n          while (parsed.hasChildNodes()) {\n            var firstChild = parsed.firstChild;\n\n            // When we polyfill everything on HTMLElement.prototype, we overwrite\n            // properties. This makes it so that parentNode reports null even though\n            // it's actually a parent of the HTML parser. For this reason,\n            // cleanNode() won't work and we must manually remove it from the\n            // parser before it is moved to the host just in case it's added as a\n            // light node but not assigned to a slot.\n            parsed.removeChild(firstChild);\n\n            this.appendChild(firstChild);\n          }\n        }\n      },\n      insertBefore: {\n        value: function value(newNode, refNode) {\n          return appendChildOrInsertBefore(this, newNode, refNode);\n        }\n      },\n      lastChild: {\n        get: function get() {\n          var ch = this.childNodes;\n          return ch[ch.length - 1] || null;\n        }\n      },\n      lastElementChild: {\n        get: function get() {\n          var ch = this.children;\n          return ch[ch.length - 1] || null;\n        }\n      },\n      name: {\n        get: function get() {\n          return this.getAttribute('name');\n        },\n        set: function set(name) {\n          return this.setAttribute('name', name);\n        }\n      },\n      nextSibling: {\n        get: function get() {\n          var host = this;\n          return eachChildNode(this.parentNode, function (child, index, nodes) {\n            if (host === child) {\n              return nodes[index + 1] || null;\n            }\n          });\n        }\n      },\n      nextElementSibling: {\n        get: function get() {\n          var host = this;\n          var found = undefined;\n          return eachChildNode(this.parentNode, function (child) {\n            if (found && child.nodeType === 1) {\n              return child;\n            }\n            if (host === child) {\n              found = true;\n            }\n          });\n        }\n      },\n      outerHTML: {\n        get: function get() {\n          var name = this.tagName.toLowerCase();\n          var attributes = Array.prototype.slice.call(this.attributes).map(function (attr) {\n            return ' ' + attr.name + (attr.value ? '=\"' + attr.value + '\"' : '');\n          }).join('');\n          return '<' + name + attributes + '>' + this.innerHTML + '</' + name + '>';\n        }\n      },\n      parentElement: {\n        get: function get() {\n          return findClosest(this.parentNode, function (node) {\n            return node.nodeType === 1;\n          });\n        }\n      },\n      parentNode: {\n        get: function get() {\n          return nodeToParentNodeMap.get(this) || this.__parentNode || null;\n        }\n      },\n      previousSibling: {\n        get: function get() {\n          var host = this;\n          return eachChildNode(this.parentNode, function (child, index, nodes) {\n            if (host === child) {\n              return nodes[index - 1] || null;\n            }\n          });\n        }\n      },\n      previousElementSibling: {\n        get: function get() {\n          var host = this;\n          var found = undefined;\n          return eachChildNode(this.parentNode, function (child) {\n            if (found && host === child) {\n              return found;\n            }\n            if (child.nodeType === 1) {\n              found = child;\n            }\n          });\n        }\n      },\n      removeChild: {\n        value: function value(refNode) {\n          var nodeType = getNodeType(this);\n\n          if (nodeType === 'node') {\n            if (canPatchNativeAccessors) {\n              return this.__removeChild(refNode);\n            } else {\n              return removeNodeFromNode(this, refNode);\n            }\n          }\n\n          if (nodeType === 'slot') {\n            return removeNodeFromNode(this, refNode);\n          }\n\n          if (nodeType === 'host') {\n            return removeNodeFromHost(this, refNode);\n          }\n\n          if (nodeType === 'root') {\n            return removeNodeFromRoot(this, refNode);\n          }\n        }\n      },\n      removeEventListener: {\n        value: function value(name, func, opts) {\n          if (name === 'slotchange' && this.____slotChangeListeners && isSlotNode(this)) {\n            this.____slotChangeListeners--;\n          }\n          return this.__removeEventListener(name, func, opts);\n        }\n      },\n      replaceChild: {\n        value: function value(newNode, refNode) {\n          this.insertBefore(newNode, refNode);\n          return this.removeChild(refNode);\n        }\n      },\n      shadowRoot: {\n        get: function get() {\n          return hostToModeMap.get(this) === 'open' ? hostToRootMap.get(this) : null;\n        }\n      },\n      textContent: {\n        get: function get() {\n          var textContent = '';\n          eachChildNode(this, function (node) {\n            textContent += node.textContent;\n          });\n          return textContent;\n        },\n        set: function set(textContent) {\n          while (this.hasChildNodes()) {\n            this.removeChild(this.firstChild);\n          }\n          this.appendChild(document.createTextNode(textContent));\n        }\n      }\n    };\n\n    function findDescriptorFor(name) {\n      for (var a = 0; a < protos.length; a++) {\n        var ctor = window[protos[a]];\n        if (!ctor) {\n          continue;\n        }\n        var proto = ctor.prototype;\n        if (proto.hasOwnProperty(name)) {\n          return Object.getOwnPropertyDescriptor(proto, name);\n        }\n      }\n    }\n\n    if (!('attachShadow' in document.createElement('div'))) {\n      (function () {\n        var elementProto = HTMLElement.prototype;\n        Object.keys(members).forEach(function (memberName) {\n          var memberProperty = members[memberName];\n\n          // All properties should be configurable.\n          memberProperty.configurable = true;\n\n          // Polyfill as much as we can and work around WebKit in other areas.\n          if (canPatchNativeAccessors || polyfilAtRuntime.indexOf(memberName) === -1) {\n            var nativeDescriptor = findDescriptorFor(memberName);\n            Object.defineProperty(elementProto, memberName, memberProperty);\n            if (nativeDescriptor && nativeDescriptor.configurable) {\n              Object.defineProperty(elementProto, '__' + memberName, nativeDescriptor);\n            }\n          }\n        });\n      })();\n    }\n\n\n\n    var api = Object.freeze({\n      default: version\n    });\n\n    var previousGlobal = window.skatejsNamedSlots;\n    version.noConflict = function noConflict() {\n      window.skatejsNamedSlots = previousGlobal;\n      return this;\n    };\n    window.skatejsNamedSlots = version;\n    for (var name in api) {\n      version[name] = api[name];\n    }\n    version.version = '0.1.4';\n\n    return version;\n\n}));\n//# sourceMappingURL=index.js.map"],"sourceRoot":"/source/"}