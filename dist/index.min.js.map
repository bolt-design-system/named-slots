{"version":3,"sources":["index.min.js"],"names":["global","factory","exports","module","define","amd","skatejsNamedSlots","this","__commonjs","fn","each","node","func","DocumentFragment","chs","childNodes","chsLen","length","a","convertXmlToHtml","nodeType","copy","document","createElement","tagName","attributes","attr","setAttribute","name","value","childNode","appendChild","parse","html","tree","parsed","parser","parseFromString","hasChildNodes","firstChild","removeChild","arrayItem","idx","makeLikeNodeList","arr","item","cleanNode","parent","parentNode","isHostNode","____rootNode","isShadowNode","____hostNode","isSlotNode","findClosest","findClosestShadowRoot","staticProp","prop","Object","defineProperty","configurable","get","getSlotNameFromSlot","getAttribute","getSlotNameFromNode","slotNodeIntoSlot","slot","insertBefore","slotInsertBeforeIndex","____assignedNodes","indexOf","assignedNodes","fallbackNodes","____isInFallbackMode","forEach","fallbackNode","__removeChild","__insertBefore","splice","__appendChild","push","____triggerSlotChangeEvent","slotNodeFromSlot","assignedSlot","index","registerNode","host","eachNode","eachIndex","unregisterNode","addNodeToNode","addNodeToHost","slotNode","____slotNodes","addNodeToRoot","root","addSlotToRoot","slotNodes","querySelectorAll","slotNodesLen","slotName","removeNodeFromNode","removeNodeFromHost","removeNodeFromRoot","removeSlotFromRoot","nodes","appendChildOrInsertBefore","newNode","refNode","closestRoot","undefined","findDescriptorFor","protos","proto","prototype","hasOwnProperty","getOwnPropertyDescriptor","index$1","now","Date","getTime","require$$0","wait","immediate","later","last","timestamp","timeout","setTimeout","result","apply","context","args","arguments","callNow","debounce","version","defaultShadowRootTagName","DOMParser","members","______assignedNodes","____slotChangeListeners","______slotChangeListeners","set","dispatchEvent","CustomEvent","bubbles","cancelable","addEventListener","opts","__addEventListener","attachShadow","mode","Error","existingShadowRoot","____shadowRoot","shadowRoot","polyfillShadowRootTagName","____unslottedNodes","concat","childElementCount","children","____childNodes","filter","firstElementChild","getAssignedNodes","innerHTML","reduce","prev","curr","outerHTML","textContent","lastChild","ch","lastElementChild","nextSibling","nextElementSibling","toLowerCase","Array","slice","call","map","join","parentElement","previousSibling","previousElementSibling","removeEventListener","__removeEventListener","replaceChild","createTextNode","Node","Element","EventTarget","elementProto","HTMLElement","keys","memberName","memberProperty","nativeDescriptor","api","freeze","default","previousGlobal","window","noConflict"],"mappings":"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","file":"index.min.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global.skatejsNamedSlots = factory());\n}(this, function () {\n\n    function __commonjs(fn, module) { return module = { exports: {} }, fn(module, module.exports), module.exports; }\n\n    var index$1 = __commonjs(function (module) {\n    module.exports = Date.now || now;\n\n    function now() {\n        return new Date().getTime();\n    }\n    });\n\n    var require$$0 = (index$1 && typeof index$1 === 'object' && 'default' in index$1 ? index$1['default'] : index$1);\n\n    var index = __commonjs(function (module) {\n    /**\n     * Module dependencies.\n     */\n\n    var now = require$$0;\n\n    /**\n     * Returns a function, that, as long as it continues to be invoked, will not\n     * be triggered. The function will be called after it stops being called for\n     * N milliseconds. If `immediate` is passed, trigger the function on the\n     * leading edge, instead of the trailing.\n     *\n     * @source underscore.js\n     * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n     * @param {Function} function to wrap\n     * @param {Number} timeout in ms (`100`)\n     * @param {Boolean} whether to execute at the beginning (`false`)\n     * @api public\n     */\n\n    module.exports = function debounce(func, wait, immediate) {\n      var timeout, args, context, timestamp, result;\n      if (null == wait) wait = 100;\n\n      function later() {\n        var last = now() - timestamp;\n\n        if (last < wait && last > 0) {\n          timeout = setTimeout(later, wait - last);\n        } else {\n          timeout = null;\n          if (!immediate) {\n            result = func.apply(context, args);\n            if (!timeout) context = args = null;\n          }\n        }\n      };\n\n      return function debounced() {\n        context = this;\n        args = arguments;\n        timestamp = now();\n        var callNow = immediate && !timeout;\n        if (!timeout) timeout = setTimeout(later, wait);\n        if (callNow) {\n          result = func.apply(context, args);\n          context = args = null;\n        }\n\n        return result;\n      };\n    };\n    });\n\n    var debounce = (index && typeof index === 'object' && 'default' in index ? index['default'] : index);\n\n    // Does something for a single node or a DocumentFragment. This is useful when\n    // working with arguments that are passed to DOM methods that work with either.\n    function each (node, func) {\n      if (node instanceof DocumentFragment) {\n        var chs = node.childNodes;\n        var chsLen = chs.length;\n        for (var a = 0; a < chsLen; a++) {\n          func(chs[a], a);\n        }\n      } else {\n        func(node, 0);\n      }\n    }\n\n    var version = '0.0.1';\n\n    var defaultShadowRootTagName = '_shadow_root_';\n\n    // Parse HTML natively.\n\n    var parser = new DOMParser();\n\n    function convertXmlToHtml(node) {\n      var nodeType = node.nodeType;\n\n      if (nodeType === 1) {\n        var copy = document.createElement(node.tagName);\n        for (var a = 0; a < node.attributes.length; a++) {\n          var attr = node.attributes[a];\n          copy.setAttribute(attr.name, attr.value);\n        }\n        for (var a = 0; a < node.childNodes.length; a++) {\n          var childNode = node.childNodes[a];\n          copy.appendChild(convertXmlToHtml(childNode));\n        }\n        return copy;\n      }\n      return node;\n    }\n\n    function parse(html) {\n      var tree = document.createElement('div');\n      var parsed = parser.parseFromString(html, 'text/xml');\n      while (parsed.hasChildNodes()) {\n        var firstChild = parsed.firstChild;\n        parsed.removeChild(firstChild);\n        tree.appendChild(convertXmlToHtml(firstChild));\n      }\n      return tree;\n    }\n\n    // Slotting helpers.\n\n    function arrayItem(idx) {\n      return this[idx];\n    }\n\n    function makeLikeNodeList(arr) {\n      arr.item = arrayItem;\n      return arr;\n    }\n\n    // If we append a child to a host, the host tells the shadow root to distribute\n    // it. If the root decides it doesn't need to be distributed, it is never\n    // removed from the old parent because in polyfill land we store a reference\n    // to the node but we don't move it. Due to that, we must explicitly remove the\n    // node from its old parent.\n    function cleanNode(node) {\n      var parent = node.parentNode;\n      if (parent) {\n        parent.removeChild(node);\n      }\n    }\n\n    function isHostNode(node) {\n      return !!node.____rootNode;\n    }\n\n    function isShadowNode(node) {\n      return !!node.____hostNode;\n    }\n\n    function isSlotNode(node) {\n      return node.tagName === 'SLOT';\n    }\n\n    function findClosest(node, func) {\n      while (node) {\n        if (node === document) {\n          break;\n        }\n        if (func(node)) {\n          return node;\n        }\n        node = node.parentNode;\n      }\n    }\n\n    function findClosestShadowRoot(node) {\n      return findClosest(node, isShadowNode);\n    }\n\n    function staticProp(node, prop, value) {\n      Object.defineProperty(node, prop, {\n        configurable: true,\n        get: function get() {\n          return value;\n        }\n      });\n    }\n\n    function getSlotNameFromSlot(node) {\n      return node.getAttribute && node.getAttribute('name') || 'default';\n    }\n\n    function getSlotNameFromNode(node) {\n      return node.getAttribute && node.getAttribute('slot') || 'default';\n    }\n\n    function slotNodeIntoSlot(slot, node, insertBefore) {\n      var slotInsertBeforeIndex = slot.____assignedNodes.indexOf(insertBefore);\n      var assignedNodes = slot.____assignedNodes;\n      var fallbackNodes = slot.childNodes;\n\n      staticProp(node, 'assignedSlot', slot);\n\n      // If there's currently no assigned nodes, there will be, so remove all fallback content.\n      if (!assignedNodes.length) {\n        slot.____isInFallbackMode = false;\n        fallbackNodes.forEach(function (fallbackNode) {\n          return slot.__removeChild(fallbackNode);\n        });\n      }\n\n      if (slotInsertBeforeIndex > -1) {\n        if (!slot.____isInFallbackMode) {\n          slot.__insertBefore(node, insertBefore);\n        }\n\n        assignedNodes.splice(slotInsertBeforeIndex, 0, node);\n      } else {\n        if (!slot.____isInFallbackMode) {\n          slot.__appendChild(node);\n        }\n\n        assignedNodes.push(node);\n      }\n\n      slot.____triggerSlotChangeEvent();\n    }\n\n    function slotNodeFromSlot(node) {\n      var slot = node.assignedSlot;\n\n      if (slot) {\n        var index = slot.____assignedNodes.indexOf(node);\n\n        if (index > -1) {\n          var assignedNodes = slot.____assignedNodes;\n\n          assignedNodes.splice(index, 1);\n          staticProp(node, 'assignedSlot', null);\n\n          // We only update the actual DOM representation if we're displaying\n          // slotted nodes.\n          if (!slot.____isInFallbackMode) {\n            slot.__removeChild(node);\n          }\n\n          // If this was the last slotted node, then insert fallback content.\n          if (!assignedNodes.length) {\n            slot.____isInFallbackMode = true;\n            slot.childNodes.forEach(function (fallbackNode) {\n              return slot.__appendChild(fallbackNode);\n            });\n          }\n\n          slot.____triggerSlotChangeEvent();\n        }\n      }\n    }\n\n    // Adds the node to the list of childNodes on the host and fakes any necessary\n    // information such as parentNode.\n    function registerNode(host, node, insertBefore, func) {\n      var index = host.childNodes.indexOf(insertBefore);\n      each(node, function (eachNode, eachIndex) {\n        func(eachNode, eachIndex);\n        staticProp(eachNode, 'parentNode', host);\n        if (index > -1) {\n          host.childNodes.splice(index + eachIndex, 0, eachNode);\n        } else {\n          host.childNodes.push(eachNode);\n        }\n      });\n    }\n\n    // Cleans up registerNode().\n    function unregisterNode(host, node, func) {\n      var index = host.childNodes.indexOf(node);\n      if (index > -1) {\n        func(node, 0);\n        staticProp(node, 'parentNode', null);\n        host.childNodes.splice(index, 1);\n      }\n    }\n\n    function addNodeToNode(host, node, insertBefore) {\n      registerNode(host, node, insertBefore, function (eachNode) {\n        host.__insertBefore(eachNode, insertBefore);\n      });\n    }\n\n    function addNodeToHost(host, node, insertBefore) {\n      registerNode(host, node, insertBefore, function (eachNode) {\n        var slotNode = host.____rootNode.____slotNodes[getSlotNameFromNode(eachNode)];\n        if (slotNode) {\n          slotNodeIntoSlot(slotNode, eachNode, insertBefore);\n        }\n      });\n    }\n\n    function addNodeToRoot(root, node, insertBefore) {\n      each(node, function (node) {\n        if (isSlotNode(node)) {\n          addSlotToRoot(root, node);\n        } else {\n          var slotNodes = node.querySelectorAll && node.querySelectorAll('slot');\n          var slotNodesLen = slotNodes.length;\n          for (var a = 0; a < slotNodesLen; a++) {\n            addSlotToRoot(root, slotNodes[a]);\n          }\n        }\n      });\n      addNodeToNode(root, node, insertBefore);\n    }\n\n    function addSlotToRoot(root, node) {\n      var slotName = getSlotNameFromSlot(node);\n      node.____isInFallbackMode = true;\n      root.____slotNodes[slotName] = node;\n      root.____hostNode.childNodes.forEach(function (eachNode) {\n        if (!eachNode.assignedSlot && slotName === getSlotNameFromNode(eachNode)) {\n          slotNodeIntoSlot(node, eachNode);\n        }\n      });\n    }\n\n    function removeNodeFromNode(host, node) {\n      unregisterNode(host, node, function () {\n        host.__removeChild(node);\n      });\n    }\n\n    function removeNodeFromHost(host, node) {\n      unregisterNode(host, node, function () {\n        slotNodeFromSlot(node);\n      });\n    }\n\n    function removeNodeFromRoot(root, node) {\n      unregisterNode(root, node, function () {\n        if (isSlotNode(node)) {\n          removeSlotFromRoot(root, node);\n        } else {\n          var nodes = node.querySelectorAll && node.querySelectorAll('slot');\n          for (var a = 0; a < nodes.length; a++) {\n            removeSlotFromRoot(root, nodes[a]);\n          }\n        }\n      });\n    }\n\n    function removeSlotFromRoot(root, node) {\n      node.____assignedNodes.forEach(slotNodeFromSlot);\n      delete root.____slotNodes[getSlotNameFromSlot(node)];\n    }\n\n    function appendChildOrInsertBefore(host, newNode, refNode) {\n      var closestRoot = undefined;\n\n      cleanNode(newNode);\n\n      if (isHostNode(host)) {\n        addNodeToHost(host, newNode, refNode);\n      } else if (isSlotNode(host)) {\n        addNodeToNode(host, newNode, refNode);\n      } else if (closestRoot = findClosestShadowRoot(host)) {\n        addNodeToRoot(closestRoot, newNode, refNode);\n      } else {\n        addNodeToNode(host, newNode, refNode);\n      }\n    }\n\n    var members = {\n      ____assignedNodes: {\n        get: function get() {\n          return this.______assignedNodes || (this.______assignedNodes = []);\n        }\n      },\n      ____slotChangeListeners: {\n        get: function get() {\n          if (typeof this.______slotChangeListeners === 'undefined') {\n            this.______slotChangeListeners = 0;\n          }\n          return this.______slotChangeListeners;\n        },\n        set: function set(value) {\n          this.______slotChangeListeners = value;\n        }\n      },\n      ____triggerSlotChangeEvent: {\n        value: debounce(function () {\n          if (this.____slotChangeListeners) {\n            this.dispatchEvent(new CustomEvent('slotchange', {\n              bubbles: false,\n              cancelable: false\n            }));\n          }\n        })\n      },\n      addEventListener: {\n        value: function value(name, func, opts) {\n          if (name === 'slotchange') {\n            this.____slotChangeListeners++;\n          }\n          return this.__addEventListener(name, func, opts);\n        }\n      },\n      appendChild: {\n        value: function value(newNode) {\n          return appendChildOrInsertBefore(this, newNode);\n        }\n      },\n      assignedSlot: {\n        get: function get() {\n          return null;\n        }\n      },\n      attachShadow: {\n        value: function value(opts) {\n          var mode = opts && opts.mode;\n          if (mode !== 'closed' && mode !== 'open') {\n            throw new Error('You must specify { mode } as \"open\" or \"closed\" to attachShadow().');\n          }\n\n          var existingShadowRoot = this.____shadowRoot;\n          if (existingShadowRoot) {\n            return existingShadowRoot;\n          }\n\n          var shadowRoot = document.createElement(opts.polyfillShadowRootTagName || defaultShadowRootTagName);\n\n          // Emulating the spec { mode }.\n          Object.defineProperty(this, 'shadowRoot', {\n            configurable: true,\n            get: function get() {\n              return mode === 'open' ? shadowRoot : null;\n            }\n          });\n\n          // Host and shadow root data.\n          this.____rootNode = shadowRoot;\n          this.____unslottedNodes = this.childNodes.concat();\n          shadowRoot.____hostNode = this;\n          shadowRoot.____slotNodes = [];\n\n          // The shadow root is actually the only child of the host.\n          return this.__appendChild(shadowRoot);\n        }\n      },\n      childElementCount: {\n        get: function get() {\n          return this.children.length;\n        }\n      },\n      childNodes: {\n        get: function get() {\n          return this.____childNodes || (this.____childNodes = makeLikeNodeList([]));\n        }\n      },\n      children: {\n        get: function get() {\n          return makeLikeNodeList(this.childNodes.filter(function (node) {\n            return node.nodeType === 1;\n          }));\n        }\n      },\n      firstChild: {\n        get: function get() {\n          return this.childNodes[0] || null;\n        }\n      },\n      firstElementChild: {\n        get: function get() {\n          return this.children[0] || null;\n        }\n      },\n      getAssignedNodes: {\n        value: function value() {\n          return this.____assignedNodes || [];\n        }\n      },\n      hasChildNodes: {\n        value: function value() {\n          return this.childNodes.length > 0;\n        }\n      },\n      innerHTML: {\n        get: function get() {\n          return this.childNodes.reduce(function (prev, curr) {\n            return prev + (curr.nodeType === 1 ? curr.outerHTML : curr.textContent);\n          }, '');\n        },\n        set: function set(innerHTML) {\n          var parsed = parse(innerHTML);\n\n          while (this.hasChildNodes()) {\n            this.removeChild(this.firstChild);\n          }\n\n          while (parsed.hasChildNodes()) {\n            var firstChild = parsed.firstChild;\n\n            // When we polyfill everything on HTMLElement.prototype, we overwrite\n            // properties. This makes it so that parentNode reports null even though\n            // it's actually a parent of the HTML parser. For this reason,\n            // cleanNode() won't work and we must manually remove it from the\n            // parser before it is moved to the host just in case it's added as a\n            // light node but not assigned to a slot.\n            parsed.removeChild(firstChild);\n\n            this.appendChild(firstChild);\n          }\n        }\n      },\n      insertBefore: {\n        value: function value(newNode, refNode) {\n          return appendChildOrInsertBefore(this, newNode, refNode);\n        }\n      },\n      lastChild: {\n        get: function get() {\n          var ch = this.childNodes;\n          return ch[ch.length - 1] || null;\n        }\n      },\n      lastElementChild: {\n        get: function get() {\n          var ch = this.children;\n          return ch[ch.length - 1] || null;\n        }\n      },\n      name: {\n        get: function get() {\n          return this.getAttribute('name');\n        },\n        set: function set(name) {\n          return this.setAttribute('name', name);\n        }\n      },\n      nextSibling: {\n        get: function get() {\n          var parentNode = this.parentNode;\n          if (parent) {\n            var childNodes = parentNode.childNodes;\n            return childNodes[childNodes.indexOf(this) + 1] || null;\n          }\n          return null;\n        }\n      },\n      nextElementSibling: {\n        get: function get() {\n          var nextSibling = this;\n          while (nextSibling = nextSibling.nextSibling) {\n            if (nextSibling.nodeType === 1) {\n              return nextSibling;\n            }\n          }\n          return null;\n        }\n      },\n      outerHTML: {\n        get: function get() {\n          var name = this.tagName.toLowerCase();\n          var attributes = Array.prototype.slice.call(this.attributes).map(function (attr) {\n            return ' ' + attr.name + (attr.value ? '=\"' + attr.value + '\"' : '');\n          }).join('');\n          return '<' + name + attributes + '>' + this.innerHTML + '</' + name + '>';\n        }\n      },\n      parentElement: {\n        get: function get() {\n          return findClosest(this.parentNode, function (node) {\n            return node.nodeType === 1;\n          });\n        }\n      },\n      previousSibling: {\n        get: function get() {\n          var parentNode = this.parentNode;\n          if (parent) {\n            var childNodes = parentNode.childNodes;\n            return childNodes[childNodes.indexOf(this) - 1] || null;\n          }\n          return null;\n        }\n      },\n      previousElementSibling: {\n        get: function get() {\n          var previousSibling = this;\n          while (previousSibling = previousSibling.previousSibling) {\n            if (previousSibling.nodeType === 1) {\n              return previousSibling;\n            }\n          }\n          return null;\n        }\n      },\n      removeChild: {\n        value: function value(refNode) {\n          var closestRoot = undefined;\n\n          if (isHostNode(this)) {\n            removeNodeFromHost(this, refNode);\n          } else if (isSlotNode(this)) {\n            removeNodeFromNode(this, refNode);\n          } else if (closestRoot = findClosestShadowRoot(this)) {\n            removeNodeFromRoot(closestRoot, refNode);\n          } else {\n            removeNodeFromNode(this, refNode);\n          }\n        }\n      },\n      removeEventListener: {\n        value: function value(name, func, opts) {\n          if (name === 'slotchange' && this.____slotChangeListeners) {\n            this.____slotChangeListeners--;\n          }\n          return this.__removeEventListener(name, func, opts);\n        }\n      },\n      replaceChild: {\n        value: function value(newNode, refNode) {\n          this.insertBefore(newNode, refNode);\n          return this.removeChild(refNode);\n        }\n      },\n      textContent: {\n        get: function get() {\n          return this.childNodes.map(function (node) {\n            return node.textContent;\n          }).join('');\n        },\n        set: function set(textContent) {\n          while (this.hasChildNodes()) {\n            this.removeChild(this.firstChild);\n          }\n          this.appendChild(document.createTextNode(textContent));\n        }\n      }\n    };\n\n    var protos = [Node, Element, EventTarget];\n    function findDescriptorFor(name) {\n      for (var a = 0; a < protos.length; a++) {\n        var proto = protos[a].prototype;\n        if (proto.hasOwnProperty(name)) {\n          return Object.getOwnPropertyDescriptor(proto, name);\n        }\n      }\n    }\n\n    if (!('attachShadow' in document.createElement('div'))) {\n      (function () {\n        var elementProto = HTMLElement.prototype;\n        Object.keys(members).forEach(function (memberName) {\n          var memberProperty = members[memberName];\n          var nativeDescriptor = findDescriptorFor(memberName);\n          memberProperty.configurable = true;\n          Object.defineProperty(elementProto, memberName, memberProperty);\n          if (nativeDescriptor && nativeDescriptor.configurable) {\n            Object.defineProperty(elementProto, '__' + memberName, nativeDescriptor);\n          }\n        });\n      })();\n    }\n\n\n\n    var api = Object.freeze({\n      default: version\n    });\n\n    var previousGlobal = window.skatejsNamedSlots;\n    version.noConflict = function noConflict() {\n      window.skatejsNamedSlots = previousGlobal;\n      return this;\n    };\n    window.skatejsNamedSlots = version;\n    for (var name in api) {\n      version[name] = api[name];\n    }\n\n    return version;\n\n}));\n//# sourceMappingURL=index.js.map"],"sourceRoot":"/source/"}