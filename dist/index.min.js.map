{"version":3,"sources":["index.min.js"],"names":["global","factory","exports","module","define","amd","skatejsNamedSlots","this","__commonjs","fn","polyfillSlot","slot","__triggerSlotChangeEvent","debounce","triggerSlotChangeEvent","queryForNamedSlot","host","name","querySelector","queryForUnnamedSlot","dispatchEvent","CustomEvent","bubbles","cancelable","getSlot","node","slotName","getAttribute","cacheKey","__slots","slots","_slotElement","parentNode","calculatedName","__shadowId","slotElement","applyParentNode","parent","mapNodeIsLightDom","set","mapPolyfilledParentNode","canPatchNativeAccessors","mapPolyfilledLightNode","get","lightProps","prop","removeParentNode","arrayItem","idx","doForNodesIfSlot","elem","func","nodes","nodeToArray","nodesLen","length","a","_node","mapSlotChangeListeners","makeLikeNodeList","arr","item","DocumentFragment","toArray","childNodes","obj","Array","prototype","slice","call","polyfill","mapPolyfilled","hostProps","funcs","polyfilled","createFragmentFromChildNodes","frag","document","createDocumentFragment","hasChildNodes","appendChild","firstChild","createShadowRoot","root","createElement","isBlockLevel","window","getComputedStyle","display","render","opts","arguments","undefined","defaults","shadowRoot","__shadowRoot","initialLightDom","shadowId","index$1","now","Date","getTime","require$$0","index","wait","immediate","later","last","timestamp","timeout","setTimeout","result","apply","context","args","callNow","WeakMap","Wm","key","delete","has","val","Object","defineProperty","bind","nodeProto","Node","elProto","Element","configurable","getOwnPropertyDescriptor","childElementCount","children","childNodesLen","push","filter","nodeType","firstElementChild","innerHTML","map","outerHTML","textContent","join","div","removeChild","lastChild","ch","lastElementChild","tagName","toLowerCase","attributes","attr","value","toString","parentElement","__parentElement","__parentNode","nextSibling","parChs","parChsLen","__nextSibling","nextElementSibling","next","__nextElementSibling","previousSibling","__previousSibling","previousElementSibling","prev","__previousElementSibling","newNode","insertBefore","refNode","replaceChild","name$1","proto","hasOwnProperty","version","api","freeze","default","previousGlobal","noConflict"],"mappings":"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","file":"index.min.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global.skatejsNamedSlots = factory());\n}(this, function () {\n\n    function __commonjs(fn, module) { return module = { exports: {} }, fn(module, module.exports), module.exports; }\n\n    var index$1 = __commonjs(function (module) {\n    module.exports = Date.now || now;\n\n    function now() {\n        return new Date().getTime();\n    }\n    });\n\n    var require$$0 = (index$1 && typeof index$1 === 'object' && 'default' in index$1 ? index$1['default'] : index$1);\n\n    var index = __commonjs(function (module) {\n    /**\n     * Module dependencies.\n     */\n\n    var now = require$$0;\n\n    /**\n     * Returns a function, that, as long as it continues to be invoked, will not\n     * be triggered. The function will be called after it stops being called for\n     * N milliseconds. If `immediate` is passed, trigger the function on the\n     * leading edge, instead of the trailing.\n     *\n     * @source underscore.js\n     * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n     * @param {Function} function to wrap\n     * @param {Number} timeout in ms (`100`)\n     * @param {Boolean} whether to execute at the beginning (`false`)\n     * @api public\n     */\n\n    module.exports = function debounce(func, wait, immediate) {\n      var timeout, args, context, timestamp, result;\n      if (null == wait) wait = 100;\n\n      function later() {\n        var last = now() - timestamp;\n\n        if (last < wait && last > 0) {\n          timeout = setTimeout(later, wait - last);\n        } else {\n          timeout = null;\n          if (!immediate) {\n            result = func.apply(context, args);\n            if (!timeout) context = args = null;\n          }\n        }\n      };\n\n      return function debounced() {\n        context = this;\n        args = arguments;\n        timestamp = now();\n        var callNow = immediate && !timeout;\n        if (!timeout) timeout = setTimeout(later, wait);\n        if (callNow) {\n          result = func.apply(context, args);\n          context = args = null;\n        }\n\n        return result;\n      };\n    };\n    });\n\n    var debounce = (index && typeof index === 'object' && 'default' in index ? index['default'] : index);\n\n    function polyfillSlot(slot) {\n      slot.__triggerSlotChangeEvent = debounce(triggerSlotChangeEvent);\n      return slot;\n    }\n\n    function queryForNamedSlot(host, name) {\n      return host.querySelector('slot[name=\"' + name + '\"], [slot-name=\"' + name + '\"]');\n    }\n\n    function queryForUnnamedSlot(host) {\n      return host.querySelector('slot[name=\"\"], slot:not([name]), [slot-name=\"\"]');\n    }\n\n    function triggerSlotChangeEvent() {\n      this.dispatchEvent(new CustomEvent('slotchange', {\n        bubbles: false,\n        cancelable: false\n      }));\n    }\n\n    function getSlot (host, node) {\n      if (!node) {\n        return;\n      }\n\n      var slotName = node.getAttribute && node.getAttribute('slot');\n      var cacheKey = slotName || 'content';\n\n      if (!host.__slots) {\n        host.__slots = {};\n      }\n\n      var slots = host.__slots;\n\n      // We check for a cached slot first because querying is slow.\n      if (slots[cacheKey]) {\n        var _slotElement = slots[cacheKey];\n\n        // However, we check to see if it was detached. If not, just return it.\n        if (_slotElement.parentNode) {\n          return _slotElement;\n        }\n\n        // if it was detached we should make sure it's cleaned up.\n        delete slots[cacheKey];\n        return null;\n      }\n\n      var calculatedName = (host.__shadowId || '') + (slotName || '');\n      var slotElement = slotName ? queryForNamedSlot(host, calculatedName) : queryForUnnamedSlot(host);\n\n      // Cache it because querying is slow.\n      if (slotElement) {\n        slots[cacheKey] = polyfillSlot(slotElement);\n      }\n\n      return slots[cacheKey] || null;\n    }\n\n    var WeakMap = window.WeakMap || function () {\n      var index = 0;\n      function Wm() {\n        this.key = '____weak_map_' + index++;\n      }\n      Wm.prototype = {\n        delete: function _delete(obj) {\n          delete obj[this.key];\n        },\n        get: function get(obj) {\n          return obj[this.key];\n        },\n        has: function has(obj) {\n          return typeof obj[this.key] !== 'undefined';\n        },\n        set: function set(obj, val) {\n          return obj[this.key] = val;\n        }\n      };\n      return Wm;\n    }();\n\n    var mapNodeIsLightDom = new WeakMap();\n\n    var mapPolyfilled = new WeakMap();\n\n    var mapPolyfilledLightNode = new WeakMap();\n\n    var mapPolyfilledParentNode = new WeakMap();\n\n    var mapSlotChangeListeners = new WeakMap();\n\n    var prop = Object.defineProperty.bind(Object);\n\n    var nodeProto = Node.prototype;\n    var elProto = Element.prototype;\n    var configurable = true;\n    var canPatchNativeAccessors = !!Object.getOwnPropertyDescriptor(Node.prototype, 'parentNode').get;\n\n    // Fake parentNode helpers.\n\n    function applyParentNode(node, parent) {\n      mapNodeIsLightDom.set(node, true);\n      mapPolyfilledParentNode.set(node, parent);\n\n      if (!canPatchNativeAccessors && !mapPolyfilledLightNode.get(node)) {\n        mapPolyfilledLightNode.set(node, true);\n        for (var name in lightProps) {\n          prop(node, name, lightProps[name]);\n        }\n      }\n    }\n\n    function removeParentNode(node) {\n      mapNodeIsLightDom.set(node, false);\n      mapPolyfilledParentNode.set(node, null);\n    }\n\n    // Slotting helpers.\n\n    function arrayItem(idx) {\n      return this[idx];\n    }\n\n    function doForNodesIfSlot(elem, node, func) {\n      var nodes = nodeToArray(node);\n      var nodesLen = nodes.length;\n\n      for (var a = 0; a < nodesLen; a++) {\n        var _node = nodes[a];\n        var slot = getSlot(elem, _node);\n\n        if (slot) {\n          func(elem, _node, slot);\n          if (mapSlotChangeListeners.get(slot)) {\n            slot.__triggerSlotChangeEvent();\n          }\n        }\n      }\n    }\n\n    function makeLikeNodeList(arr) {\n      arr.item = arrayItem;\n      return arr;\n    }\n\n    function nodeToArray(node) {\n      return node instanceof DocumentFragment ? toArray(node.childNodes) : [node];\n    }\n\n    function toArray(obj) {\n      return Array.prototype.slice.call(obj);\n    }\n\n    // Prop overrides.\n\n    var hostProps = {\n      childElementCount: {\n        configurable: configurable,\n        get: function get() {\n          return this.children.length;\n        }\n      },\n      childNodes: {\n        get: function get() {\n          var nodes = [];\n          var slots = this.__slots;\n          if (slots) {\n            for (var name in slots) {\n              var slot = slots[name];\n              var childNodes = slot.childNodes;\n              var childNodesLen = childNodes.length;\n              for (var a = 0; a < childNodesLen; a++) {\n                nodes.push(childNodes[a]);\n              }\n            }\n          }\n          return makeLikeNodeList(nodes);\n        }\n      },\n      children: {\n        get: function get() {\n          return makeLikeNodeList(this.childNodes.filter(function (node) {\n            return node.nodeType === 1;\n          }));\n        }\n      },\n      firstChild: {\n        get: function get() {\n          return this.childNodes[0] || null;\n        }\n      },\n      firstElementChild: {\n        get: function get() {\n          return this.children[0] || null;\n        }\n      },\n      innerHTML: {\n        get: function get() {\n          return this.childNodes.map(function (node) {\n            return node.outerHTML || node.textContent;\n          }).join('');\n        },\n        set: function set(val) {\n          var div = document.createElement('div');\n          var frag = document.createDocumentFragment();\n\n          // TODO: This may not be foolproof with incompatible child nodes.\n          div.innerHTML = val;\n\n          // Ensure existing nodes are cleaned up properly.\n          while (this.hasChildNodes()) {\n            this.removeChild(this.firstChild);\n          }\n\n          // Ensures new nodes are set up properly.\n          while (div.hasChildNodes()) {\n            frag.appendChild(div.firstChild);\n          }\n\n          this.appendChild(frag);\n        }\n      },\n      lastChild: {\n        get: function get() {\n          var ch = this.childNodes;\n          return ch[ch.length - 1] || null;\n        }\n      },\n      lastElementChild: {\n        get: function get() {\n          var ch = this.children;\n          return ch[ch.length - 1] || null;\n        }\n      },\n      outerHTML: {\n        get: function get() {\n          var name = this.tagName.toLowerCase();\n          var attributes = toArray(this.attributes).map(function (attr) {\n            return ' ' + attr.name + (attr.value ? '=\"' + attr.value + '\"' : '');\n          }).join('');\n          return '<' + name + attributes + '>' + this.innerHTML + '</' + name + '>';\n        }\n      },\n      textContent: {\n        get: function get() {\n          return this.childNodes.map(function (node) {\n            return node.textContent;\n          }).join('');\n        },\n        set: function set(val) {\n          // Ensure existing nodes are cleaned up properly.\n          while (this.hasChildNodes()) {\n            this.removeChild(this.firstChild);\n          }\n\n          doForNodesIfSlot(this, val.toString(), function (elem, node, slot) {\n            slot.textContent = node;\n          });\n        }\n      }\n    };\n\n    var lightProps = {\n      parentElement: {\n        configurable: configurable,\n        get: function get() {\n          if (mapNodeIsLightDom.get(this)) {\n            var parent = this.parentNode;\n            return parent.nodeType === 1 ? parent : null;\n          }\n          return this.__parentElement;\n        }\n      },\n      parentNode: {\n        configurable: configurable,\n        get: function get() {\n          return mapPolyfilledParentNode.get(this) || this.__parentNode || null;\n        }\n      },\n      nextSibling: {\n        configurable: configurable,\n        get: function get() {\n          if (mapNodeIsLightDom.get(this)) {\n            var index = undefined;\n            var parChs = this.parentNode.childNodes;\n            var parChsLen = parChs.length;\n            for (var a = 0; a < parChsLen; a++) {\n              if (parChs[a] === this) {\n                index = a;\n                continue;\n              }\n            }\n            return typeof index === 'number' ? parChs[index + 1] : null;\n          }\n          return this.__nextSibling;\n        }\n      },\n      nextElementSibling: {\n        configurable: configurable,\n        get: function get() {\n          if (mapNodeIsLightDom.get(this)) {\n            var next = undefined;\n            while (next = this.nextSibling) {\n              if (next.nodeType === 1) {\n                return next;\n              }\n            }\n            return null;\n          }\n          return this.__nextElementSibling;\n        }\n      },\n      previousSibling: {\n        configurable: configurable,\n        get: function get() {\n          if (mapNodeIsLightDom.get(this)) {\n            var index = undefined;\n            var parChs = this.parentNode.childNodes;\n            var parChsLen = parChs.length;\n            for (var a = 0; a < parChsLen; a++) {\n              if (parChs[a] === this) {\n                index = a;\n                continue;\n              }\n            }\n            return typeof index === 'number' ? parChs[index - 1] : null;\n          }\n          return this.__previousSibling;\n        }\n      },\n      previousElementSibling: {\n        configurable: configurable,\n        get: function get() {\n          if (mapNodeIsLightDom.get(this)) {\n            var prev = undefined;\n            while (prev = this.previousSibling) {\n              if (prev.nodeType === 1) {\n                return prev;\n              }\n            }\n            return null;\n          }\n          return this.__previousElementSibling;\n        }\n      }\n    };\n\n    // Method overrides.\n\n    var funcs = {\n      appendChild: function appendChild(newNode) {\n        doForNodesIfSlot(this, newNode, function (elem, node, slot) {\n          slot.appendChild(node);\n          applyParentNode(node, elem);\n        });\n        return newNode;\n      },\n      hasChildNodes: function hasChildNodes() {\n        return this.childNodes.length > 0;\n      },\n      insertBefore: function insertBefore(newNode, refNode) {\n        doForNodesIfSlot(this, newNode, function (elem, node, slot) {\n          slot.insertBefore(node, refNode);\n          applyParentNode(node, elem);\n        });\n        return newNode;\n      },\n      removeChild: function removeChild(refNode) {\n        doForNodesIfSlot(this, refNode, function (elem, node, slot) {\n          slot.removeChild(node);\n          removeParentNode(node);\n        });\n        return refNode;\n      },\n      replaceChild: function replaceChild(newNode, refNode) {\n        // If the ref node is not in the light DOM, just return it.\n        if (refNode.parentNode !== this) {\n          return refNode;\n        }\n\n        // We're dealing with a representation of the light DOM, so we insert nodes\n        // relative to the location of the refNode in the light DOM, not the where\n        // it appears in the composed DOM.\n        var insertBefore = refNode.nextSibling;\n\n        // Clean up the reference node.\n        this.removeChild(refNode);\n\n        // Add new nodes in place of the reference node.\n        doForNodesIfSlot(this, newNode, function (elem, node, slot) {\n          slot.insertBefore(node, insertBefore);\n          applyParentNode(node, elem);\n        });\n\n        return refNode;\n      }\n    };\n\n    // If we can patch native accessors, we can safely apply light DOM accessors to\n    // all HTML elements. This is faster than polyfilling them individually as they\n    // are added, if possible, and doesn't have a measurable impact on performance\n    // when they're not marked as light DOM.\n    if (canPatchNativeAccessors) {\n      for (var name$1 in lightProps) {\n        var proto = nodeProto.hasOwnProperty(name$1) ? nodeProto : elProto;\n        prop(proto, '__' + name$1, Object.getOwnPropertyDescriptor(proto, name$1));\n        prop(proto, name$1, lightProps[name$1]);\n      }\n    }\n\n    // Polyfills a host element.\n    function polyfill(elem) {\n      if (mapPolyfilled.get(elem)) {\n        return;\n      }\n\n      for (var name in hostProps) {\n        prop(elem, name, hostProps[name]);\n      }\n\n      for (var name in funcs) {\n        elem[name] = funcs[name];\n      }\n\n      mapPolyfilled.set(elem, true);\n      return elem;\n    }\n\n    // Returns whether or not the specified element has been polyfilled.\n    function polyfilled (elem) {\n      return mapPolyfilled.get(elem);\n    }\n\n    // Returns a document fragment of the childNodes of the specified element. Due\n    // to the nature of the DOM, this will remove the nodes from the element.\n    function createFragmentFromChildNodes(elem) {\n      var frag = document.createDocumentFragment();\n      while (elem.hasChildNodes()) {\n        frag.appendChild(elem.firstChild);\n      }\n      return frag;\n    }\n\n    // Creates an shadow root, appends it to the element and returns it.\n    function createShadowRoot(elem) {\n      var root = document.createElement(isBlockLevel(elem) ? 'div' : 'span');\n      elem.appendChild(root);\n      return root;\n    }\n\n    // Returns whether or not the specified element is a block level element or not\n    // We need this to determine the type of element the shadow root should be\n    // since we must use real nodes to simulate a shadow root.\n    function isBlockLevel(elem) {\n      return window.getComputedStyle(elem).display === 'block';\n    }\n\n    // Simple renderer that proxies another renderer. It will polyfill if not yet\n    // polyfilled, or simply run the renderer. Initial content is taken into\n    // consideration.\n    var defaults = { shadowId: '' };\n    function render (fn) {\n      var opts = arguments.length <= 1 || arguments[1] === undefined ? defaults : arguments[1];\n\n      return function (elem) {\n        var shadowRoot = elem.__shadowRoot;\n\n        if (shadowRoot) {\n          fn(elem, shadowRoot);\n        } else {\n          // We get a fragment of the initial DOM so that we can create the shadow\n          // root.\n          var initialLightDom = createFragmentFromChildNodes(elem);\n\n          // Create a shadow ID so that it can be used to get a slot that is unique\n          // to this shadow root. Since we don't polyfill querySelector() et al, we\n          // need a way to be able to refer to slots that are unique to this\n          // shadow root.\n          elem.__shadowId = opts.shadowId;\n\n          // Create the shadow root and return the light DOM. We must get the light\n          // DOM before we template it so that we can distribute it after\n          // polyfilling.\n          elem.__shadowRoot = createShadowRoot(elem);\n\n          // Render once we have the initial light DOM as this would likely blow\n          // that away.\n          fn(elem, elem.__shadowRoot);\n\n          // Now polyfill so that we can distribute after.\n          polyfill(elem);\n\n          // Distribute the initial light DOM after polyfill so they get put into\n          // the right spots.\n          elem.appendChild(initialLightDom);\n        }\n      };\n    }\n\n    var version = '0.0.1';\n\n\n\n    var api = Object.freeze({\n    \tdefault: polyfill,\n    \tpolyfilled: polyfilled,\n    \trender: render,\n    \tversion: version\n    });\n\n    var previousGlobal = window.skatejsNamedSlots;\n    polyfill.noConflict = function noConflict() {\n      window.skatejsNamedSlots = previousGlobal;\n      return this;\n    };\n    window.skatejsNamedSlots = polyfill;\n    for (var name in api) {\n      polyfill[name] = api[name];\n    }\n\n    return polyfill;\n\n}));\n//# sourceMappingURL=index.js.map"],"sourceRoot":"/source/"}