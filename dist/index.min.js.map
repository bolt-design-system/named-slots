{"version":3,"sources":["index.min.js"],"names":["global","factory","exports","module","define","amd","skatejsNamedSlots","this","__commonjs","fn","eachChildNode","node","func","chs","childNodes","chsLen","length","a","ret","eachNodeOrFragmentNodes","DocumentFragment","getPrototype","obj","key","descriptor","undefined","Object","getOwnPropertyDescriptor","getPrototypeOf","getPropertyDescriptor","Node","div","proto","getter","get","setter","set","_descriptor","configurable","enumerable","value","getEscapedTextContent","textNode","textContent","replace","getCommentNodeOuterHtml","commentNode","text","parse","html","tree","document","createElement","canPatchNativeAccessors","__innerHTML","parsed","parser","parseFromString","body","firstChild","hasChildNodes","removeChild","appendChild","importNode","staticProp","name","defineProperty","arrayItem","idx","makeLikeNodeList","arr","item","getNodeType","isHostNode","isSlotNode","isRootNode","hostToRootMap","tagName","defaultShadowRootTagNameUc","findClosest","parentNode","getSlotNameFromSlot","getAttribute","getSlotNameFromNode","slotNodeIntoSlot","slot","insertBefore","nodeType","trim","assignedNodes","getAssignedNodes","shouldGoIntoContentMode","slotInsertBeforeIndex","indexOf","nodeToSlotMap","forEach","call","__removeChild","__insertBefore","splice","__appendChild","push","____triggerSlotChangeEvent","slotNodeFromSlot","assignedSlot","index","shouldGoIntoDefaultMode","indexOfNode","host","registerNode","eachNode","eachIndex","nodeToParentNodeMap","arrProto","unregisterNode","addNodeToNode","addNodeToHost","rootNode","slotNodes","rootToSlotMap","slotNode","addNodeToRoot","root","addSlotToRoot","querySelectorAll","slotNodesLen","addNodeToSlot","isInDefaultMode","removeNodeFromSlot","slotName","rootToHostMap","removeNodeFromNode","removeNodeFromHost","removeNodeFromRoot","removeSlotFromRoot","nodes","getRootNode","appendChildOrInsertBefore","newNode","refNode","babelHelpers","Symbol","iterator","constructor","nativeParentNode","Element","prototype","index$1","now","Date","getTime","require$$0","wait","immediate","later","last","timestamp","timeout","setTimeout","result","apply","context","args","arguments","callNow","debounce","version","weakmap","undefined_","object","nameOf","defProp","writable","toSource","match","funcName","createStorage","creator","storage","WM","defaultCreator","getProps","getOwnPropertyNames","Function","toString","create","hasOwn","hasOwnProperty","Data","puid","createUID","secret","unlock","store","data","dataDesc","datalock","uids","Math","random","slice","globalID","isExtensible","TypeError","props","o","v","WeakMap","iterable","wrap","initialize","validate","unwrap","has","delete_","had","collection","i","Array","src","del","e","split","stringifier","prep","__proto__","f","method","eval","ce","window","CustomEvent","bubbles","cancelable","detail","x","preventDefault","defaultPrevented","Error","CustomEvent$1","event","params","evt","createEvent","initCustomEvent","origPrevent","Event","defaultShadowRootTagName","toUpperCase","polyfillAtRuntime","doNotOverridePropertiesInTextNodes","assignedToSlotMap","hostToModeMap","nodeToChildNodesMap","DOMParser","members","____assignedNodes","______assignedNodes","____isInFallbackMode","____slotChangeListeners","______slotChangeListeners","dispatchEvent","addEventListener","opts","__addEventListener","attachShadow","_this","mode","existingShadowRoot","lightNodes","shadowRoot","polyfillShadowRootTagName","childElementCount","children","__childNodes","firstElementChild","assigned","innerHTML","getHtmlNodeOuterHtml","outerHTML","getOuterHtmlByNodeType",1,3,8,"getOuterHtml","lastChild","ch","lastElementChild","setAttribute","nextSibling","child","nextElementSibling","found","toLowerCase","attributes","map","attr","join","parentElement","__parentNode","previousSibling","previousElementSibling","removeEventListener","__removeEventListener","replaceChild","COMMENT_NODE","createTextNode","elementProto","HTMLElement","textProto","Text","keys","memberName","memberProperty","nativeDescriptor","nativeTextDescriptor","shouldOverrideInTextNode","api","freeze","default","previousGlobal","noConflict"],"mappings":"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","file":"index.min.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global.skatejsNamedSlots = factory());\n}(this, function () {\n\n    var babelHelpers = {};\n    babelHelpers.typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n      return typeof obj;\n    } : function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n    };\n    babelHelpers;\n\n\n    function __commonjs(fn, module) { return module = { exports: {} }, fn(module, module.exports), module.exports; }\n\n    function eachChildNode(node, func) {\n      if (!node) {\n        return;\n      }\n\n      var chs = node.childNodes;\n      var chsLen = chs.length;\n      for (var a = 0; a < chsLen; a++) {\n        var ret = func(chs[a], a, chs);\n        if (typeof ret !== 'undefined') {\n          return ret;\n        }\n      }\n    }\n\n    function eachNodeOrFragmentNodes(node, func) {\n      if (node instanceof DocumentFragment) {\n        var chs = node.childNodes;\n        var chsLen = chs.length;\n        for (var a = 0; a < chsLen; a++) {\n          func(chs[a], a);\n        }\n      } else {\n        func(node, 0);\n      }\n    }\n\n    var div = document.createElement('div');\n\n    function getPrototype(obj, key) {\n      var descriptor = undefined;\n\n      while (obj && !(descriptor = Object.getOwnPropertyDescriptor(obj, key))) {\n        obj = Object.getPrototypeOf(obj);\n      }\n      return descriptor;\n    }\n    function getPropertyDescriptor (obj, key) {\n      if (obj instanceof Node) {\n        obj = div;\n      }\n      var proto = getPrototype(obj, key);\n\n      if (proto) {\n        var getter = proto.get;\n        var setter = proto.set;\n        var _descriptor = {\n          configurable: true,\n          enumerable: true\n        };\n\n        if (getter) {\n          _descriptor.get = getter;\n          _descriptor.set = setter;\n          return _descriptor;\n        } else if (typeof obj[key] === 'function') {\n          _descriptor.value = obj[key];\n          return _descriptor;\n        }\n      }\n\n      var descriptor = Object.getOwnPropertyDescriptor(obj, key);\n      if (descriptor && descriptor.get) {\n        return descriptor;\n      }\n    }\n\n    var nativeParentNode = getPropertyDescriptor(Element.prototype, 'innerHTML');\n\n    var canPatchNativeAccessors = !!nativeParentNode;\n\n    var index$1 = __commonjs(function (module) {\n    module.exports = Date.now || now;\n\n    function now() {\n        return new Date().getTime();\n    }\n    });\n\n    var require$$0 = (index$1 && typeof index$1 === 'object' && 'default' in index$1 ? index$1['default'] : index$1);\n\n    var index = __commonjs(function (module) {\n    /**\n     * Module dependencies.\n     */\n\n    var now = require$$0;\n\n    /**\n     * Returns a function, that, as long as it continues to be invoked, will not\n     * be triggered. The function will be called after it stops being called for\n     * N milliseconds. If `immediate` is passed, trigger the function on the\n     * leading edge, instead of the trailing.\n     *\n     * @source underscore.js\n     * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n     * @param {Function} function to wrap\n     * @param {Number} timeout in ms (`100`)\n     * @param {Boolean} whether to execute at the beginning (`false`)\n     * @api public\n     */\n\n    module.exports = function debounce(func, wait, immediate) {\n      var timeout, args, context, timestamp, result;\n      if (null == wait) wait = 100;\n\n      function later() {\n        var last = now() - timestamp;\n\n        if (last < wait && last > 0) {\n          timeout = setTimeout(later, wait - last);\n        } else {\n          timeout = null;\n          if (!immediate) {\n            result = func.apply(context, args);\n            if (!timeout) context = args = null;\n          }\n        }\n      };\n\n      return function debounced() {\n        context = this;\n        args = arguments;\n        timestamp = now();\n        var callNow = immediate && !timeout;\n        if (!timeout) timeout = setTimeout(later, wait);\n        if (callNow) {\n          result = func.apply(context, args);\n          context = args = null;\n        }\n\n        return result;\n      };\n    };\n    });\n\n    var debounce = (index && typeof index === 'object' && 'default' in index ? index['default'] : index);\n\n    /**\n     * See https://w3c.github.io/DOM-Parsing/#serializing\n     * @param {TextNode}\n     * @returns {string}\n     */\n    function getEscapedTextContent(textNode) {\n      return textNode.textContent.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n    }\n\n    /**\n     * @returns {string}\n     * @param {commentNode}\n     */\n    function getCommentNodeOuterHtml(commentNode) {\n      return commentNode.text || \"<!--\" + commentNode.textContent + \"-->\";\n    }\n\n    var version = '0.0.1';\n\n    var weakmap = __commonjs(function (module, exports) {\n    /* (The MIT License)\r\n     *\r\n     * Copyright (c) 2012 Brandon Benvie <http://bbenvie.com>\r\n     *\r\n     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and\r\n     * associated documentation files (the 'Software'), to deal in the Software without restriction,\r\n     * including without limitation the rights to use, copy, modify, merge, publish, distribute,\r\n     * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is\r\n     * furnished to do so, subject to the following conditions:\r\n     *\r\n     * The above copyright notice and this permission notice shall be included with all copies or\r\n     * substantial portions of the Software.\r\n     *\r\n     * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\r\n     * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  CLAIM,\r\n     * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n     */\n\n    // Original WeakMap implementation by Gozala @ https://gist.github.com/1269991\n    // Updated and bugfixed by Raynos @ https://gist.github.com/1638059\n    // Expanded by Benvie @ https://github.com/Benvie/harmony-collections\n\n    void function (global, undefined_, undefined) {\n      var getProps = Object.getOwnPropertyNames,\n          defProp = Object.defineProperty,\n          toSource = Function.prototype.toString,\n          create = Object.create,\n          hasOwn = Object.prototype.hasOwnProperty,\n          funcName = /^\\n?function\\s?(\\w*)?_?\\(/;\n\n      function define(object, key, value) {\n        if (typeof key === 'function') {\n          value = key;\n          key = nameOf(value).replace(/_$/, '');\n        }\n        return defProp(object, key, { configurable: true, writable: true, value: value });\n      }\n\n      function nameOf(func) {\n        return typeof func !== 'function' ? '' : 'name' in func ? func.name : toSource.call(func).match(funcName)[1];\n      }\n\n      // ############\n      // ### Data ###\n      // ############\n\n      var Data = function () {\n        var dataDesc = { value: { writable: true, value: undefined } },\n            datalock = 'return function(k){if(k===s)return l}',\n            uids = create(null),\n            createUID = function createUID() {\n          var key = Math.random().toString(36).slice(2);\n          return key in uids ? createUID() : uids[key] = key;\n        },\n            globalID = createUID(),\n            storage = function storage(obj) {\n          if (hasOwn.call(obj, globalID)) return obj[globalID];\n\n          if (!Object.isExtensible(obj)) throw new TypeError(\"Object must be extensible\");\n\n          var store = create(null);\n          defProp(obj, globalID, { value: store });\n          return store;\n        };\n\n        // common per-object storage area made visible by patching getOwnPropertyNames'\n        define(Object, function getOwnPropertyNames(obj) {\n          var props = getProps(obj);\n          if (hasOwn.call(obj, globalID)) props.splice(props.indexOf(globalID), 1);\n          return props;\n        });\n\n        function Data() {\n          var puid = createUID(),\n              secret = {};\n\n          this.unlock = function (obj) {\n            var store = storage(obj);\n            if (hasOwn.call(store, puid)) return store[puid](secret);\n\n            var data = create(null, dataDesc);\n            defProp(store, puid, {\n              value: new Function('s', 'l', datalock)(secret, data)\n            });\n            return data;\n          };\n        }\n\n        define(Data.prototype, function get(o) {\n          return this.unlock(o).value;\n        });\n        define(Data.prototype, function set(o, v) {\n          this.unlock(o).value = v;\n        });\n\n        return Data;\n      }();\n\n      var WM = function (data) {\n        var validate = function validate(key) {\n          if (key == null || (typeof key === 'undefined' ? 'undefined' : babelHelpers.typeof(key)) !== 'object' && typeof key !== 'function') throw new TypeError(\"Invalid WeakMap key\");\n        };\n\n        var wrap = function wrap(collection, value) {\n          var store = data.unlock(collection);\n          if (store.value) throw new TypeError(\"Object is already a WeakMap\");\n          store.value = value;\n        };\n\n        var unwrap = function unwrap(collection) {\n          var storage = data.unlock(collection).value;\n          if (!storage) throw new TypeError(\"WeakMap is not generic\");\n          return storage;\n        };\n\n        var initialize = function initialize(weakmap, iterable) {\n          if (iterable !== null && (typeof iterable === 'undefined' ? 'undefined' : babelHelpers.typeof(iterable)) === 'object' && typeof iterable.forEach === 'function') {\n            iterable.forEach(function (item, i) {\n              if (item instanceof Array && item.length === 2) set.call(weakmap, iterable[i][0], iterable[i][1]);\n            });\n          }\n        };\n\n        function WeakMap(iterable) {\n          if (this === global || this == null || this === WeakMap.prototype) return new WeakMap(iterable);\n\n          wrap(this, new Data());\n          initialize(this, iterable);\n        }\n\n        function get(key) {\n          validate(key);\n          var value = unwrap(this).get(key);\n          return value === undefined_ ? undefined : value;\n        }\n\n        function set(key, value) {\n          validate(key);\n          // store a token for explicit undefined so that \"has\" works correctly\n          unwrap(this).set(key, value === undefined ? undefined_ : value);\n        }\n\n        function has(key) {\n          validate(key);\n          return unwrap(this).get(key) !== undefined;\n        }\n\n        function delete_(key) {\n          validate(key);\n          var data = unwrap(this),\n              had = data.get(key) !== undefined;\n          data.set(key, undefined);\n          return had;\n        }\n\n        function toString() {\n          unwrap(this);\n          return '[object WeakMap]';\n        }\n\n        try {\n          var src = ('return ' + delete_).replace('e_', '\\\\u0065'),\n              del = new Function('unwrap', 'validate', src)(unwrap, validate);\n        } catch (e) {\n          var del = delete_;\n        }\n\n        var src = ('' + Object).split('Object');\n        var stringifier = function toString() {\n          return src[0] + nameOf(this) + src[1];\n        };\n\n        define(stringifier, stringifier);\n\n        var prep = { __proto__: [] } instanceof Array ? function (f) {\n          f.__proto__ = stringifier;\n        } : function (f) {\n          define(f, stringifier);\n        };\n\n        prep(WeakMap);\n\n        [toString, get, set, has, del].forEach(function (method) {\n          define(WeakMap.prototype, method);\n          prep(method);\n        });\n\n        return WeakMap;\n      }(new Data());\n\n      var defaultCreator = Object.create ? function () {\n        return Object.create(null);\n      } : function () {\n        return {};\n      };\n\n      function createStorage(creator) {\n        var weakmap = new WM();\n        creator || (creator = defaultCreator);\n\n        function storage(object, value) {\n          if (value || arguments.length === 2) {\n            weakmap.set(object, value);\n          } else {\n            value = weakmap.get(object);\n            if (value === undefined) {\n              value = creator(object);\n              weakmap.set(object, value);\n            }\n          }\n          return value;\n        }\n\n        return storage;\n      }\n\n      if (typeof module !== 'undefined') {\n        module.exports = WM;\n      } else if (typeof exports !== 'undefined') {\n        exports.WeakMap = WM;\n      } else if (!('WeakMap' in global)) {\n        global.WeakMap = WM;\n      }\n\n      WM.createStorage = createStorage;\n      if (global.WeakMap) global.WeakMap.createStorage = createStorage;\n    }((0, eval)('this'));\n    });\n\n    var WeakMap = (weakmap && typeof weakmap === 'object' && 'default' in weakmap ? weakmap['default'] : weakmap);\n\n    // Polyfill for creating CustomEvents on IE9/10/11\n\n    // code pulled from:\n    // https://github.com/d4tocchini/customevent-polyfill\n    // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent#Polyfill\n\n    try {\n        var ce = new window.CustomEvent('test', {\n            bubbles: false,\n            cancelable: true,\n            detail: {\n                x: 'y'\n            }\n        });\n        ce.preventDefault();\n        if (ce.defaultPrevented !== true) {\n            // IE has problems with .preventDefault() on custom events\n            // http://stackoverflow.com/questions/23349191\n            throw new Error('Could not prevent default');\n        }\n    } catch (e) {\n        var CustomEvent$1 = function CustomEvent(event, params) {\n            var evt;\n            params = params || {\n                bubbles: false,\n                cancelable: false,\n                detail: undefined\n            };\n\n            evt = document.createEvent(\"CustomEvent\");\n            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n            var origPrevent = evt.preventDefault;\n            evt.preventDefault = function () {\n                origPrevent.call(this);\n                try {\n                    Object.defineProperty(this, 'defaultPrevented', {\n                        get: function get() {\n                            return true;\n                        }\n                    });\n                } catch (e) {\n                    this.defaultPrevented = true;\n                }\n            };\n            return evt;\n        };\n\n        CustomEvent$1.prototype = window.Event.prototype;\n        window.CustomEvent = CustomEvent$1; // expose definition to window\n    }\n\n    var arrProto = Array.prototype;\n    var forEach = arrProto.forEach;\n\n    // We use a real DOM node for a shadow root. This is because the host node\n    // basically becomes a virtual entry point for your element leaving the shadow\n    // root the only thing that can receive instructions on how the host should\n    // render to the browser.\n\n    var defaultShadowRootTagName = '_shadow_root_';\n    var defaultShadowRootTagNameUc = defaultShadowRootTagName.toUpperCase();\n\n    // * WebKit only *\n    //\n    // These members we need cannot override as we require native access to their\n    // original values at some point.\n    var polyfillAtRuntime = ['childNodes', 'parentNode'];\n\n    // Some properties that should not be overridden in the Text prototype.\n    var doNotOverridePropertiesInTextNodes = ['textContent'];\n\n    // Private data stores.\n    var assignedToSlotMap = new WeakMap();\n    var hostToModeMap = new WeakMap();\n    var hostToRootMap = new WeakMap();\n    var nodeToChildNodesMap = new WeakMap();\n    var nodeToParentNodeMap = new WeakMap();\n    var nodeToSlotMap = new WeakMap();\n    var rootToHostMap = new WeakMap();\n    var rootToSlotMap = new WeakMap();\n\n    // Unfortunately manual DOM parsing is because of WebKit.\n    var parser = new DOMParser();\n    function parse(html) {\n      var tree = document.createElement('div');\n\n      // Everything not WebKit can do this easily.\n      if (canPatchNativeAccessors) {\n        tree.__innerHTML = html;\n        return tree;\n      }\n\n      var parsed = parser.parseFromString('<div>' + html + '</div>', 'text/html').body.firstChild;\n\n      while (parsed.hasChildNodes()) {\n        var firstChild = parsed.firstChild;\n        parsed.removeChild(firstChild);\n        tree.appendChild(firstChild);\n      }\n\n      // Need to import the node to initialise the custom elements from the parser.\n      return document.importNode(tree, true);\n    }\n\n    function staticProp(obj, name, value) {\n      Object.defineProperty(obj, name, {\n        configurable: true,\n        get: function get() {\n          return value;\n        }\n      });\n    }\n\n    // Slotting helpers.\n\n    function arrayItem(idx) {\n      return this[idx];\n    }\n\n    function makeLikeNodeList(arr) {\n      arr.item = arrayItem;\n      return arr;\n    }\n\n    function getNodeType(node) {\n      if (isHostNode(node)) {\n        return 'host';\n      }\n\n      if (isSlotNode(node)) {\n        return 'slot';\n      }\n\n      if (isRootNode(node)) {\n        return 'root';\n      }\n\n      return 'node';\n    }\n\n    function isHostNode(node) {\n      return !!hostToRootMap.get(node);\n    }\n\n    function isSlotNode(node) {\n      return node.tagName === 'SLOT';\n    }\n\n    function isRootNode(node) {\n      return node.tagName === defaultShadowRootTagNameUc;\n    }\n\n    function findClosest(node, func) {\n      while (node) {\n        if (node === document) {\n          break;\n        }\n        if (func(node)) {\n          return node;\n        }\n        node = node.parentNode;\n      }\n    }\n\n    function getSlotNameFromSlot(node) {\n      return node.getAttribute && node.getAttribute('name') || 'default';\n    }\n\n    function getSlotNameFromNode(node) {\n      return node.getAttribute && node.getAttribute('slot') || 'default';\n    }\n\n    function slotNodeIntoSlot(slot, node, insertBefore) {\n      // Don't slot nodes that have content but are only whitespace. This is an\n      // anomaly that I don't think the spec deals with.\n      //\n      // The problem is:\n      //\n      // - If you insert HTML with indentation into the page, there will be\n      //   whitespace and if that's inserted it messes with fallback content\n      //   calculation where there is formatting, but no meaningful content, so in\n      //   theory it should fallback. Since you can attach a shadow root after we\n      //   mean to insert an empty text node and have it \"count\", we can't really\n      //   discard nodes that are considered formatting at the time of attachment.\n      // - You can insert a text node and modify its text content later.\n      //   Incremental DOM seems to do this. Every way I look at it, it seems\n      //   problematic that we should have to screen for content, but I don't seems\n      //   much of a way around it at the moment.\n      if (node.nodeType === 3 && node.textContent && node.textContent.trim().length === 0) {\n        return;\n      }\n\n      var assignedNodes = slot.getAssignedNodes();\n      var shouldGoIntoContentMode = assignedNodes.length === 0;\n      var slotInsertBeforeIndex = assignedNodes.indexOf(insertBefore);\n\n      // Assign the slot to the node internally.\n      nodeToSlotMap.set(node, slot);\n\n      // Remove the fallback content and state if we're going into content mode.\n      if (shouldGoIntoContentMode) {\n        forEach.call(slot.childNodes, function (node) {\n          return slot.__removeChild(node);\n        });\n      }\n\n      if (slotInsertBeforeIndex > -1) {\n        slot.__insertBefore(node, insertBefore !== undefined ? insertBefore : null);\n        assignedNodes.splice(slotInsertBeforeIndex, 0, node);\n      } else {\n        slot.__appendChild(node);\n        assignedNodes.push(node);\n      }\n\n      slot.____triggerSlotChangeEvent();\n    }\n\n    function slotNodeFromSlot(node) {\n      var slot = node.assignedSlot;\n\n      if (slot) {\n        var assignedNodes = slot.getAssignedNodes();\n        var index = assignedNodes.indexOf(node);\n\n        if (index > -1) {\n          var shouldGoIntoDefaultMode = assignedNodes.length === 1;\n\n          assignedNodes.splice(index, 1);\n          nodeToSlotMap.set(node, null);\n\n          // Actually remove the child.\n          slot.__removeChild(node);\n\n          // If this was the last slotted node, then insert fallback content.\n          if (shouldGoIntoDefaultMode) {\n            forEach.call(slot.childNodes, function (node) {\n              return slot.__appendChild(node);\n            });\n          }\n\n          slot.____triggerSlotChangeEvent();\n        }\n      }\n    }\n\n    // Returns the index of the node in the host's childNodes.\n    function indexOfNode(host, node) {\n      var chs = host.childNodes;\n      var chsLen = chs.length;\n      for (var a = 0; a < chsLen; a++) {\n        if (chs[a] === node) {\n          return a;\n        }\n      }\n      return -1;\n    }\n\n    // Adds the node to the list of childNodes on the host and fakes any necessary\n    // information such as parentNode.\n    function registerNode(host, node, insertBefore, func) {\n      var index = indexOfNode(host, insertBefore);\n      eachNodeOrFragmentNodes(node, function (eachNode, eachIndex) {\n        func(eachNode, eachIndex);\n\n        if (canPatchNativeAccessors) {\n          nodeToParentNodeMap.set(eachNode, host);\n        } else {\n          staticProp(eachNode, 'parentNode', host);\n        }\n\n        if (index > -1) {\n          arrProto.splice.call(host.childNodes, index + eachIndex, 0, eachNode);\n        } else {\n          arrProto.push.call(host.childNodes, eachNode);\n        }\n      });\n    }\n\n    // Cleans up registerNode().\n    function unregisterNode(host, node, func) {\n      var index = indexOfNode(host, node);\n\n      if (index > -1) {\n        func(node, 0);\n\n        if (canPatchNativeAccessors) {\n          nodeToParentNodeMap.set(node, null);\n        } else {\n          staticProp(node, 'parentNode', null);\n        }\n\n        arrProto.splice.call(host.childNodes, index, 1);\n      }\n    }\n\n    function addNodeToNode(host, node, insertBefore) {\n      registerNode(host, node, insertBefore, function (eachNode) {\n        host.__insertBefore(eachNode, insertBefore !== undefined ? insertBefore : null);\n      });\n    }\n\n    function addNodeToHost(host, node, insertBefore) {\n      registerNode(host, node, insertBefore, function (eachNode) {\n        var rootNode = hostToRootMap.get(host);\n        var slotNodes = rootToSlotMap.get(rootNode);\n        var slotNode = slotNodes[getSlotNameFromNode(eachNode)];\n        if (slotNode) {\n          slotNodeIntoSlot(slotNode, eachNode, insertBefore);\n        }\n      });\n    }\n\n    function addNodeToRoot(root, node, insertBefore) {\n      eachNodeOrFragmentNodes(node, function (node) {\n        if (isSlotNode(node)) {\n          addSlotToRoot(root, node);\n        } else {\n          var slotNodes = node.querySelectorAll && node.querySelectorAll('slot');\n          if (slotNodes) {\n            var slotNodesLen = slotNodes.length;\n            for (var a = 0; a < slotNodesLen; a++) {\n              addSlotToRoot(root, slotNodes[a]);\n            }\n          }\n        }\n      });\n      addNodeToNode(root, node, insertBefore);\n    }\n\n    // Adds a node to a slot. In other words, adds default content to a slot. It\n    // ensures that if the slot doesn't have any assigned nodes yet, that the node\n    // is actually displayed, otherwise it's just registered as child content.\n    function addNodeToSlot(slot, node, insertBefore) {\n      var isInDefaultMode = slot.getAssignedNodes().length === 0;\n      registerNode(slot, node, insertBefore, function (eachNode) {\n        if (isInDefaultMode) {\n          slot.__insertBefore(eachNode, insertBefore !== undefined ? insertBefore : null);\n        }\n      });\n    }\n\n    // Removes a node from a slot (default content). It ensures that if the slot\n    // doesn't have any assigned nodes yet, that the node is actually removed,\n    // otherwise it's just unregistered.\n    function removeNodeFromSlot(slot, node) {\n      var isInDefaultMode = slot.getAssignedNodes().length === 0;\n      unregisterNode(slot, node, function () {\n        if (isInDefaultMode) {\n          slot.__removeChild(node);\n        }\n      });\n    }\n\n    function addSlotToRoot(root, slot) {\n      var slotName = getSlotNameFromSlot(slot);\n\n      // Ensure a slot node's childNodes are overridden at the earliest point\n      // possible for WebKit.\n      if (!canPatchNativeAccessors && !slot.childNodes.push) {\n        staticProp(slot, 'childNodes', []);\n      }\n\n      rootToSlotMap.get(root)[slotName] = slot;\n      eachChildNode(rootToHostMap.get(root), function (eachNode) {\n        if (!eachNode.assignedSlot && slotName === getSlotNameFromNode(eachNode)) {\n          slotNodeIntoSlot(slot, eachNode);\n        }\n      });\n    }\n\n    function removeNodeFromNode(host, node) {\n      unregisterNode(host, node, function () {\n        host.__removeChild(node);\n      });\n    }\n\n    function removeNodeFromHost(host, node) {\n      unregisterNode(host, node, function () {\n        slotNodeFromSlot(node);\n      });\n    }\n\n    function removeNodeFromRoot(root, node) {\n      unregisterNode(root, node, function () {\n        if (isSlotNode(node)) {\n          removeSlotFromRoot(root, node);\n        } else {\n          var nodes = node.querySelectorAll && node.querySelectorAll('slot');\n          for (var a = 0; a < nodes.length; a++) {\n            removeSlotFromRoot(root, nodes[a]);\n          }\n        }\n      });\n    }\n\n    function removeSlotFromRoot(root, node) {\n      node.getAssignedNodes().forEach(slotNodeFromSlot);\n      delete rootToSlotMap.get(root)[getSlotNameFromSlot(node)];\n    }\n\n    // TODO terribly inefficient\n    function getRootNode(host) {\n      if (isRootNode(host)) {\n        return host;\n      } else {\n        if (!host.parentNode) {\n          return;\n        }\n\n        return getRootNode(host.parentNode);\n      }\n    }\n\n    function appendChildOrInsertBefore(host, newNode, refNode) {\n      var nodeType = getNodeType(host);\n      var parentNode = newNode.parentNode;\n      var rootNode = getRootNode(host);\n\n      // Ensure childNodes is patched so we can manually update it for WebKit.\n      if (!canPatchNativeAccessors && !host.childNodes.push) {\n        staticProp(host, 'childNodes', []);\n      }\n\n      if (rootNode && getNodeType(newNode) === 'slot') {\n        addSlotToRoot(rootNode, newNode);\n      }\n\n      // If we append a child to a host, the host tells the shadow root to distribute\n      // it. If the root decides it doesn't need to be distributed, it is never\n      // removed from the old parent because in polyfill land we store a reference\n      // to the node but we don't move it. Due to that, we must explicitly remove the\n      // node from its old parent.\n      if (parentNode && getNodeType(parentNode) === 'host') {\n        if (canPatchNativeAccessors) {\n          nodeToParentNodeMap.set(newNode, null);\n        } else {\n          staticProp(newNode, 'parentNode', null);\n        }\n      }\n\n      if (nodeType === 'node') {\n        if (canPatchNativeAccessors) {\n          nodeToParentNodeMap.set(newNode, host);\n          return host.__insertBefore(newNode, refNode !== undefined ? refNode : null);\n        } else {\n          return addNodeToNode(host, newNode, refNode);\n        }\n      }\n\n      if (nodeType === 'slot') {\n        return addNodeToSlot(host, newNode, refNode);\n      }\n\n      if (nodeType === 'host') {\n        return addNodeToHost(host, newNode, refNode);\n      }\n\n      if (nodeType === 'root') {\n        return addNodeToRoot(host, newNode, refNode);\n      }\n    }\n\n    var members = {\n      // For testing purposes.\n      ____assignedNodes: {\n        get: function get() {\n          return this.______assignedNodes || (this.______assignedNodes = []);\n        }\n      },\n\n      // For testing purposes.\n      ____isInFallbackMode: {\n        get: function get() {\n          return this.getAssignedNodes().length === 0;\n        }\n      },\n\n      ____slotChangeListeners: {\n        get: function get() {\n          if (typeof this.______slotChangeListeners === 'undefined') {\n            this.______slotChangeListeners = 0;\n          }\n          return this.______slotChangeListeners;\n        },\n        set: function set(value) {\n          this.______slotChangeListeners = value;\n        }\n      },\n      ____triggerSlotChangeEvent: {\n        value: debounce(function () {\n          if (this.____slotChangeListeners) {\n            this.dispatchEvent(new CustomEvent('slotchange', {\n              bubbles: false,\n              cancelable: false\n            }));\n          }\n        })\n      },\n      addEventListener: {\n        value: function value(name, func, opts) {\n          if (name === 'slotchange' && isSlotNode(this)) {\n            this.____slotChangeListeners++;\n          }\n          return this.__addEventListener(name, func, opts);\n        }\n      },\n      appendChild: {\n        value: function value(newNode) {\n          return appendChildOrInsertBefore(this, newNode);\n        }\n      },\n      assignedSlot: {\n        get: function get() {\n          return nodeToSlotMap.get(this) || null;\n        }\n      },\n      attachShadow: {\n        value: function value(opts) {\n          var _this = this;\n\n          var mode = opts && opts.mode;\n          if (mode !== 'closed' && mode !== 'open') {\n            throw new Error('You must specify { mode } as \"open\" or \"closed\" to attachShadow().');\n          }\n\n          // Return the existing shadow root if it exists.\n          var existingShadowRoot = hostToRootMap.get(this);\n          if (existingShadowRoot) {\n            return existingShadowRoot;\n          }\n\n          var lightNodes = makeLikeNodeList([].slice.call(this.childNodes));\n          var shadowRoot = document.createElement(opts.polyfillShadowRootTagName || defaultShadowRootTagName);\n\n          // Host and shadow root data.\n          hostToModeMap.set(this, mode);\n          hostToRootMap.set(this, shadowRoot);\n          rootToHostMap.set(shadowRoot, this);\n          rootToSlotMap.set(shadowRoot, {});\n\n          if (canPatchNativeAccessors) {\n            nodeToChildNodesMap.set(this, lightNodes);\n          } else {\n            staticProp(this, 'childNodes', lightNodes);\n          }\n\n          // Process light DOM.\n          lightNodes.forEach(function (node) {\n            // Existing children should be removed from being displayed, but still\n            // appear to be child nodes. This is how light DOM works; they're still\n            // child nodes but not in the composed DOM yet as there won't be any\n            // slots for them to go into.\n            _this.__removeChild(node);\n\n            // We must register the parentNode here as this has the potential to\n            // become out of sync if the node is moved before being slotted.\n            if (canPatchNativeAccessors) {\n              nodeToParentNodeMap.set(node, _this);\n            } else {\n              staticProp(node, 'parentNode', _this);\n            }\n          });\n\n          // The shadow root is actually the only child of the host.\n          return this.__appendChild(shadowRoot);\n        }\n      },\n      childElementCount: {\n        get: function get() {\n          return this.children.length;\n        }\n      },\n      childNodes: {\n        get: function get() {\n          if (canPatchNativeAccessors && getNodeType(this) === 'node') {\n            return this.__childNodes;\n          }\n          var childNodes = nodeToChildNodesMap.get(this);\n          childNodes || nodeToChildNodesMap.set(this, childNodes = makeLikeNodeList([]));\n          return childNodes;\n        }\n      },\n      children: {\n        get: function get() {\n          var chs = [];\n          eachChildNode(this, function (node) {\n            if (node.nodeType === 1) {\n              chs.push(node);\n            }\n          });\n          return makeLikeNodeList(chs);\n        }\n      },\n      firstChild: {\n        get: function get() {\n          return this.childNodes[0] || null;\n        }\n      },\n      firstElementChild: {\n        get: function get() {\n          return this.children[0] || null;\n        }\n      },\n      getAssignedNodes: {\n        value: function value() {\n          if (isSlotNode(this)) {\n            var assigned = assignedToSlotMap.get(this);\n            assigned || assignedToSlotMap.set(this, assigned = []);\n            return assigned;\n          }\n        }\n      },\n      hasChildNodes: {\n        value: function value() {\n          return this.childNodes.length > 0;\n        }\n      },\n      innerHTML: {\n        get: function get() {\n          var innerHTML = '';\n\n          var getHtmlNodeOuterHtml = function getHtmlNodeOuterHtml(node) {\n            return node.outerHTML;\n          };\n          var getOuterHtmlByNodeType = {\n            1: getHtmlNodeOuterHtml,\n            3: getEscapedTextContent,\n            8: getCommentNodeOuterHtml\n          };\n\n          eachChildNode(this, function (node) {\n            var getOuterHtml = getOuterHtmlByNodeType[node.nodeType] || getHtmlNodeOuterHtml;\n            innerHTML += getOuterHtml(node);\n          });\n          return innerHTML;\n        },\n        set: function set(innerHTML) {\n          var parsed = parse(innerHTML);\n\n          while (this.hasChildNodes()) {\n            this.removeChild(this.firstChild);\n          }\n\n          while (parsed.hasChildNodes()) {\n            var firstChild = parsed.firstChild;\n\n            // When we polyfill everything on HTMLElement.prototype, we overwrite\n            // properties. This makes it so that parentNode reports null even though\n            // it's actually a parent of the HTML parser. For this reason,\n            // cleanNode() won't work and we must manually remove it from the\n            // parser before it is moved to the host just in case it's added as a\n            // light node but not assigned to a slot.\n            parsed.removeChild(firstChild);\n\n            this.appendChild(firstChild);\n          }\n        }\n      },\n      insertBefore: {\n        value: function value(newNode, refNode) {\n          return appendChildOrInsertBefore(this, newNode, refNode);\n        }\n      },\n      lastChild: {\n        get: function get() {\n          var ch = this.childNodes;\n          return ch[ch.length - 1] || null;\n        }\n      },\n      lastElementChild: {\n        get: function get() {\n          var ch = this.children;\n          return ch[ch.length - 1] || null;\n        }\n      },\n      name: {\n        get: function get() {\n          return this.getAttribute('name');\n        },\n        set: function set(name) {\n          return this.setAttribute('name', name);\n        }\n      },\n      nextSibling: {\n        get: function get() {\n          var host = this;\n          return eachChildNode(this.parentNode, function (child, index, nodes) {\n            if (host === child) {\n              return nodes[index + 1] || null;\n            }\n          });\n        }\n      },\n      nextElementSibling: {\n        get: function get() {\n          var host = this;\n          var found = undefined;\n          return eachChildNode(this.parentNode, function (child) {\n            if (found && child.nodeType === 1) {\n              return child;\n            }\n            if (host === child) {\n              found = true;\n            }\n          });\n        }\n      },\n      outerHTML: {\n        get: function get() {\n          var name = this.tagName.toLowerCase();\n          var attributes = Array.prototype.slice.call(this.attributes).map(function (attr) {\n            return ' ' + attr.name + (attr.value ? '=\"' + attr.value + '\"' : '');\n          }).join('');\n          return '<' + name + attributes + '>' + this.innerHTML + '</' + name + '>';\n        }\n      },\n      parentElement: {\n        get: function get() {\n          return findClosest(this.parentNode, function (node) {\n            return node.nodeType === 1;\n          });\n        }\n      },\n      parentNode: {\n        get: function get() {\n          return nodeToParentNodeMap.get(this) || this.__parentNode || null;\n        }\n      },\n      previousSibling: {\n        get: function get() {\n          var host = this;\n          return eachChildNode(this.parentNode, function (child, index, nodes) {\n            if (host === child) {\n              return nodes[index - 1] || null;\n            }\n          });\n        }\n      },\n      previousElementSibling: {\n        get: function get() {\n          var host = this;\n          var found = undefined;\n          return eachChildNode(this.parentNode, function (child) {\n            if (found && host === child) {\n              return found;\n            }\n            if (child.nodeType === 1) {\n              found = child;\n            }\n          });\n        }\n      },\n      removeChild: {\n        value: function value(refNode) {\n          var nodeType = getNodeType(this);\n\n          if (nodeType === 'node') {\n            if (canPatchNativeAccessors) {\n              return this.__removeChild(refNode);\n            } else {\n              return removeNodeFromNode(this, refNode);\n            }\n          }\n\n          if (nodeType === 'slot') {\n            return removeNodeFromSlot(this, refNode);\n          }\n\n          if (nodeType === 'host') {\n            return removeNodeFromHost(this, refNode);\n          }\n\n          if (nodeType === 'root') {\n            return removeNodeFromRoot(this, refNode);\n          }\n        }\n      },\n      removeEventListener: {\n        value: function value(name, func, opts) {\n          if (name === 'slotchange' && this.____slotChangeListeners && isSlotNode(this)) {\n            this.____slotChangeListeners--;\n          }\n          return this.__removeEventListener(name, func, opts);\n        }\n      },\n      replaceChild: {\n        value: function value(newNode, refNode) {\n          this.insertBefore(newNode, refNode);\n          return this.removeChild(refNode);\n        }\n      },\n      shadowRoot: {\n        get: function get() {\n          return hostToModeMap.get(this) === 'open' ? hostToRootMap.get(this) : null;\n        }\n      },\n      textContent: {\n        get: function get() {\n          var textContent = '';\n          eachChildNode(this, function (node) {\n            if (node.nodeType !== Node.COMMENT_NODE) {\n              textContent += node.textContent;\n            }\n          });\n          return textContent;\n        },\n        set: function set(textContent) {\n          while (this.hasChildNodes()) {\n            this.removeChild(this.firstChild);\n          }\n          if (!textContent) {\n            return;\n          }\n          this.appendChild(document.createTextNode(textContent));\n        }\n      }\n    };\n\n    if (!('attachShadow' in document.createElement('div'))) {\n      (function () {\n        var elementProto = HTMLElement.prototype;\n        var textProto = Text.prototype;\n        var textNode = document.createTextNode('');\n\n        Object.keys(members).forEach(function (memberName) {\n          var memberProperty = members[memberName];\n\n          // All properties should be configurable.\n          memberProperty.configurable = true;\n\n          // Applying to the data properties only since we can't have writable accessor properties.\n          if (memberProperty.hasOwnProperty('value')) {\n            memberProperty.writable = true;\n          }\n\n          // Polyfill as much as we can and work around WebKit in other areas.\n          if (canPatchNativeAccessors || polyfillAtRuntime.indexOf(memberName) === -1) {\n            var nativeDescriptor = getPropertyDescriptor(elementProto, memberName);\n            var nativeTextDescriptor = getPropertyDescriptor(textProto, memberName);\n            var shouldOverrideInTextNode = memberName in textNode && doNotOverridePropertiesInTextNodes.indexOf(memberName) === -1;\n\n            Object.defineProperty(elementProto, memberName, memberProperty);\n\n            if (nativeDescriptor) {\n              Object.defineProperty(elementProto, '__' + memberName, nativeDescriptor);\n            }\n\n            if (shouldOverrideInTextNode) {\n              Object.defineProperty(textProto, memberName, memberProperty);\n            }\n\n            if (shouldOverrideInTextNode && nativeTextDescriptor) {\n              Object.defineProperty(textProto, '__' + memberName, nativeDescriptor);\n            }\n          }\n        });\n      })();\n    }\n\n\n\n    var api = Object.freeze({\n      default: version\n    });\n\n    var previousGlobal = window.skatejsNamedSlots;\n    version.noConflict = function noConflict() {\n      window.skatejsNamedSlots = previousGlobal;\n      return this;\n    };\n    window.skatejsNamedSlots = version;\n    for (var name in api) {\n      version[name] = api[name];\n    }\n    version.version = '0.1.9';\n\n    return version;\n\n}));\n//# sourceMappingURL=index.js.map"],"sourceRoot":"/source/"}