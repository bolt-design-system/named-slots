{"version":3,"sources":["index.min.js"],"names":["global","factory","exports","module","define","amd","skatejsNamedSlots","this","__commonjs","fn","shouldAffectSlot","slot","fallbackState","get","toggle","aNodes","assignedNodes","length","fNodes","fallbackNodes","forEach","node","removeChild","call","appendChild","set","triggerEvent","changeListeners","debouncedTriggerSlotChangeEvent","triggerSideEffects","getSlotName","getAttribute","getSlotNode","root","slots","distribute","host","parentNode","roots","an","ns","nextSibling","shouldManip","assignedSlot","splice","indexOf","insertBefore","push","undistribute","index","fragFromHtml","html","frag","document","createElement","innerHTML","htmlFromFrag","chs","childNodes","chsLen","a","outerHTML","each","func","DocumentFragment","polyfill$3","light","polyfilled","canPatchNativeAccessors","Object","defineProperties","members$3","arrayItem","idx","makeLikeNodeList","arr","item","cleanNode","parent","polyfill$1","polyfilled$2","lightNodes","members$1","getInitialFallbackContent","getAssignedNodesDeep","shouldAffectSlot$1","triggerSlotChangeEvent","dispatchEvent","CustomEvent","bubbles","cancelable","polyfill$2","debounce","members$2","slotPolyfill","polyfilled$1","createFragmentFromChildNodes","elem","createDocumentFragment","hasChildNodes","firstChild","createShadowRoot","isBlockLevel","window","getComputedStyle","display","cacheSlots","oldSlots","tagName","name","hosts","hostChs","hostChsLen","ch","newSlots","querySelectorAll","newSlotsLen","uncacheSlots","getAssignedNodes","aNode","nodeType","polyfill","_ref","arguments","undefined","mode","shadowRoot","initialLightDom","defineProperty","configurable","members","createFragmentFromChildNodes$1","createShadowRoot$1","isBlockLevel$1","render","opts","defaults","__shadowRoot","__shadowId","shadowId","WeakMap","Wm","key","prototype","delete","obj","has","val","proto","Node","replaceChild","getOwnPropertyDescriptor","configurable$1","parentElement","__parentElement","__parentNode","parChs","parChsLen","__nextSibling","nextElementSibling","found","next","__nextElementSibling","previousSibling","__previousSibling","previousElementSibling","__previousElementSibling","nodeProto","elProto","Element","name$1","proto$1","hasOwnProperty","nativeDescriptor","newNode","refNode","value","ln","childElementCount","children","filter","firstElementChild","copy","lastChild","lastElementChild","toLowerCase","attributes","Array","slice","map","attr","join","textContent","createTextNode","index$1","now","Date","getTime","require$$0","wait","immediate","later","last","timestamp","timeout","setTimeout","result","apply","context","args","callNow","deep","fb","setAttribute","attrs","tag","str","attrsLen","nodeName","nodeValue","ret","version","attachShadow","api","freeze","default","previousGlobal","noConflict"],"mappings":"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","file":"index.min.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global.skatejsNamedSlots = factory());\n}(this, function () {\n\n    function __commonjs(fn, module) { return module = { exports: {} }, fn(module, module.exports), module.exports; }\n\n    var WeakMap = window.WeakMap || function () {\n      var index = 0;\n      function Wm() {\n        this.key = '____weak_map_' + index++;\n      }\n      Wm.prototype = {\n        delete: function _delete(obj) {\n          delete obj[this.key];\n        },\n        get: function get(obj) {\n          return obj[this.key];\n        },\n        has: function has(obj) {\n          return typeof obj[this.key] !== 'undefined';\n        },\n        set: function set(obj, val) {\n          return obj[this.key] = val;\n        }\n      };\n      return Wm;\n    }();\n\n    var hosts = new WeakMap();\n    var roots = new WeakMap();\n    var slots = new WeakMap();\n\n    var proto = Node.prototype;\n    var appendChild = proto.appendChild;\n    var insertBefore = proto.insertBefore;\n    var removeChild = proto.removeChild;\n    var replaceChild = proto.replaceChild;\n\n    var assignedSlot = new WeakMap();\n    var light = new WeakMap();\n    var parentNode = new WeakMap();\n    var polyfilled = new WeakMap();\n\n    var assignedNodes = new WeakMap();\n    var changeListeners = new WeakMap();\n    var debouncedTriggerSlotChangeEvent = new WeakMap();\n    var fallbackNodes = new WeakMap();\n    var fallbackState = new WeakMap();\n    var polyfilled$1 = new WeakMap();\n\n    function shouldAffectSlot(slot) {\n      return !fallbackState.get(slot);\n    }\n\n    function toggle(slot) {\n      if (fallbackState.get(slot)) {\n        var aNodes = assignedNodes.get(slot);\n        if (aNodes.length) {\n          var fNodes = fallbackNodes.get(slot);\n          fNodes.forEach(function (node) {\n            return removeChild.call(slot, node);\n          });\n          aNodes.forEach(function (node) {\n            return appendChild.call(slot, node);\n          });\n          fallbackState.set(slot, false);\n        }\n      } else {\n        var aNodes = assignedNodes.get(slot);\n        if (!aNodes.length) {\n          var fNodes = fallbackNodes.get(slot);\n          aNodes.forEach(function (node) {\n            return removeChild.call(slot, node);\n          });\n          fNodes.forEach(function (node) {\n            return appendChild.call(slot, node);\n          });\n          fallbackState.set(slot, true);\n        }\n      }\n    }\n\n    function triggerEvent(slot) {\n      if (changeListeners.get(slot)) {\n        debouncedTriggerSlotChangeEvent.get(slot)(slot);\n      }\n    }\n\n    function triggerSideEffects(slot) {\n      toggle(slot);\n      triggerEvent(slot);\n    }\n\n    function getSlotName(node) {\n      return (node.getAttribute ? node.getAttribute('slot') : null) || 'default';\n    }\n\n    function getSlotNode(root, node) {\n      var slot = getSlotName(node);\n      return slots.get(root)[slot];\n    }\n\n    function distribute (node) {\n      var host = node.parentNode;\n      var slot = getSlotNode(roots.get(host), node);\n\n      if (slot) {\n        var an = assignedNodes.get(slot);\n        var ns = node.nextSibling;\n        var shouldManip = shouldAffectSlot(slot);\n\n        assignedSlot.set(node, slot);\n\n        if (ns && ns.assignedSlot === slot) {\n          an.splice(an.indexOf(ns), 0, node);\n          shouldManip && insertBefore.call(slot, node, ns);\n        } else {\n          an.push(node);\n          shouldManip && appendChild.call(slot, node);\n        }\n\n        triggerSideEffects(slot);\n      }\n    }\n\n    function undistribute(node) {\n      var host = node.parentNode;\n      var slot = getSlotNode(roots.get(host), node);\n\n      if (slot) {\n        var an = assignedNodes.get(slot);\n        var index = an.indexOf(node);\n\n        if (index > -1) {\n          shouldAffectSlot(slot) && removeChild.call(slot, node);\n          assignedSlot.set(node, null);\n          an.splice(index, 1);\n          triggerSideEffects(slot);\n        }\n      }\n    }\n\n    function fragFromHtml (html) {\n      var frag = document.createElement('div');\n      frag.innerHTML = html;\n      return frag;\n    }\n\n    function htmlFromFrag (frag) {\n      var html = '';\n      var chs = frag.childNodes;\n      var chsLen = chs.length;\n      for (var a = 0; a < chsLen; a++) {\n        html += chs[a].outerHTML;\n      }\n      return html;\n    }\n\n    var lightNodes = new WeakMap();\n    var polyfilled$2 = new WeakMap();\n\n    // Does something for a single node or a DocumentFragment. This is useful when\n    // working with arguments that are passed to DOM methods that work with either.\n    function each (node, func) {\n      if (node instanceof DocumentFragment) {\n        var chs = node.childNodes;\n        var chsLen = chs.length;\n        for (var a = 0; a < chsLen; a++) {\n          func(chs[a]);\n        }\n      } else {\n        func(node);\n      }\n    }\n\n    // Any code referring to this is because it has to work around this bug in\n    // WebKit: https://bugs.webkit.org/show_bug.cgi?id=49739\n    var canPatchNativeAccessors = !!Object.getOwnPropertyDescriptor(Node.prototype, 'parentNode').get;\n\n    var configurable$1 = true;\n    var members$3 = {\n      assignedSlot: {\n        configurable: configurable$1,\n        get: function get() {\n          return assignedSlot.get(this) || null;\n        }\n      },\n      parentElement: {\n        configurable: configurable$1,\n        get: function get() {\n          if (light.get(this)) {\n            var parent = this.parentNode;\n            return parent.nodeType === 1 ? parent : null;\n          }\n          return this.__parentElement;\n        }\n      },\n      parentNode: {\n        configurable: configurable$1,\n        get: function get() {\n          return parentNode.get(this) || this.__parentNode || null;\n        }\n      },\n      nextSibling: {\n        configurable: configurable$1,\n        get: function get() {\n          if (light.get(this)) {\n            var parChs = this.parentNode.childNodes;\n            var parChsLen = parChs.length;\n            for (var a = 0; a < parChsLen; a++) {\n              if (parChs[a] === this) {\n                return parChs[a + 1] || null;\n              }\n            }\n          }\n          return this.__nextSibling;\n        }\n      },\n      nextElementSibling: {\n        configurable: configurable$1,\n        get: function get() {\n          if (light.get(this)) {\n            var parChs = this.parentNode.childNodes;\n            var parChsLen = parChs.length;\n\n            var found = false;\n            for (var a = 0; a < parChsLen; a++) {\n              if (!found && parChs[a] === this) {\n                found = true;\n              }\n\n              if (!found) {\n                continue;\n              }\n\n              var next = parChs[a + 1];\n              if (next && next.nodeType === 1) {\n                return next;\n              } else {\n                continue;\n              }\n            }\n          }\n          return this.__nextElementSibling;\n        }\n      },\n      previousSibling: {\n        configurable: configurable$1,\n        get: function get() {\n          if (light.get(this)) {\n            var parChs = this.parentNode.childNodes;\n            var parChsLen = parChs.length;\n            for (var a = parChsLen - 1; a >= 0; a--) {\n              if (parChs[a] === this) {\n                return parChs[a - 1] || null;\n              }\n            }\n          }\n          return this.__previousSibling;\n        }\n      },\n      previousElementSibling: {\n        configurable: configurable$1,\n        get: function get() {\n          if (light.get(this)) {\n            var parChs = this.parentNode.childNodes;\n            var parChsLen = parChs.length;\n\n            var found = false;\n            for (var a = parChsLen - 1; a >= 0; a--) {\n              if (!found && parChs[a] === this) {\n                found = true;\n              }\n\n              if (!found) {\n                continue;\n              }\n\n              var next = parChs[a - 1];\n              if (next && next.nodeType === 1) {\n                return next;\n              } else {\n                continue;\n              }\n            }\n          }\n          return this.__previousElementSibling;\n        }\n      }\n    };\n\n    // If we can patch native accessors, we can safely apply light DOM accessors to\n    // all HTML elements. This is faster than polyfilling them individually as they\n    // are added, if possible, and doesn't have a measurable impact on performance\n    // when they're not marked as light DOM.\n    var nodeProto = Node.prototype;\n    var elProto = Element.prototype;\n    if (canPatchNativeAccessors) {\n      for (var name$1 in members$3) {\n        var proto$1 = nodeProto.hasOwnProperty(name$1) ? nodeProto : elProto;\n        var nativeDescriptor = Object.getOwnPropertyDescriptor(proto$1, name$1);\n        if (nativeDescriptor) {\n          Object.defineProperty(proto$1, '__' + name$1, nativeDescriptor);\n        }\n        Object.defineProperty(proto$1, name$1, members$3[name$1]);\n      }\n    }\n\n    // We patch the node prototype to ensure any method that reparents a node\n    // cleans up after the polyfills.\n    nodeProto.appendChild = function (newNode) {\n      if (polyfilled.get(newNode)) {\n        assignedSlot.set(newNode, null);\n        light.set(newNode, false);\n        parentNode.set(newNode, this);\n      }\n      return appendChild.call(this, newNode);\n    };\n    nodeProto.insertBefore = function (newNode, refNode) {\n      if (polyfilled.get(newNode)) {\n        assignedSlot.set(newNode, null);\n        light.set(newNode, false);\n        parentNode.set(newNode, this);\n      }\n      return insertBefore.call(this, newNode, refNode);\n    };\n    nodeProto.removeChild = function (refNode) {\n      if (polyfilled.get(refNode)) {\n        assignedSlot.set(refNode, null);\n        light.set(refNode, false);\n        parentNode.set(refNode, null);\n      }\n      return removeChild.call(this, refNode);\n    };\n    nodeProto.replaceChild = function (newNode, refNode) {\n      if (polyfilled.get(newNode)) {\n        assignedSlot.set(newNode, null);\n        light.set(newNode, false);\n        parentNode.set(newNode, this);\n      }\n      if (polyfilled.get(refNode)) {\n        assignedSlot.set(refNode, null);\n        light.set(refNode, false);\n        parentNode.set(refNode, null);\n      }\n      return replaceChild.call(this, newNode, refNode);\n    };\n\n    // By default we should always return null from the Element for `assignedSlot`.\n    Object.defineProperty(nodeProto, 'assignedSlot', {\n      configurable: configurable$1,\n      get: function get() {\n        return null;\n      }\n    });\n\n    function polyfill$3(light) {\n      if (polyfilled.get(light)) {\n        return;\n      }\n      polyfilled.set(light, true);\n      if (!canPatchNativeAccessors) {\n        Object.defineProperties(light, members$3);\n      }\n    }\n\n    var configurable = true;\n\n    // Slotting helpers.\n\n    function arrayItem(idx) {\n      return this[idx];\n    }\n\n    function makeLikeNodeList(arr) {\n      arr.item = arrayItem;\n      return arr;\n    }\n\n    // If we append a child to a host, the host tells the shadow root to distribute\n    // it. If the root decides it doesn't need to be distributed, it is never\n    // removed from the old parent because in polyfill land we store a reference\n    // to the node but we don't move it. Due to that, we must explicitly remove the\n    // node from its old parent.\n    function cleanNode(node) {\n      var parent = node.parentNode;\n      if (parent) {\n        parent.removeChild(node);\n      }\n    }\n\n    var members$1 = {\n      appendChild: {\n        value: function value(newNode) {\n          var ln = lightNodes.get(this);\n          var host = this;\n          cleanNode(newNode);\n          each(newNode, function (node) {\n            ln.push(node);\n            light.set(node, true);\n            parentNode.set(node, host);\n            polyfill$3(node);\n            distribute(node);\n          });\n          return newNode;\n        }\n      },\n      childElementCount: {\n        configurable: configurable,\n        get: function get() {\n          return this.children.length;\n        }\n      },\n      childNodes: {\n        get: function get() {\n          return lightNodes.get(this);\n        }\n      },\n      children: {\n        get: function get() {\n          return makeLikeNodeList(this.childNodes.filter(function (node) {\n            return node.nodeType === 1;\n          }));\n        }\n      },\n      firstChild: {\n        get: function get() {\n          return this.childNodes[0] || null;\n        }\n      },\n      firstElementChild: {\n        get: function get() {\n          return this.children[0] || null;\n        }\n      },\n      hasChildNodes: {\n        value: function value() {\n          return this.childNodes.length > 0;\n        }\n      },\n      innerHTML: {\n        get: function get() {\n          return htmlFromFrag(this);\n        },\n        set: function set(innerHTML) {\n          var copy = fragFromHtml(innerHTML);\n          while (this.hasChildNodes()) {\n            this.removeChild(this.firstChild);\n          }\n          while (copy.hasChildNodes()) {\n            this.appendChild(copy.firstChild);\n          }\n        }\n      },\n      insertBefore: {\n        value: function value(newNode, refNode) {\n          var ln = lightNodes.get(this);\n          var host = this;\n          cleanNode(newNode);\n          each(newNode, function (node) {\n            var index = ln.indexOf(refNode);\n            if (index > -1) {\n              ln.splice(index, 0, node);\n            } else {\n              ln.push(node);\n            }\n            light.set(node, true);\n            parentNode.set(node, host);\n            polyfill$3(node);\n            distribute(node);\n          });\n          return newNode;\n        }\n      },\n      lastChild: {\n        get: function get() {\n          var ch = this.childNodes;\n          return ch[ch.length - 1] || null;\n        }\n      },\n      lastElementChild: {\n        get: function get() {\n          var ch = this.children;\n          return ch[ch.length - 1] || null;\n        }\n      },\n      outerHTML: {\n        get: function get() {\n          var name = this.tagName.toLowerCase();\n          var attributes = Array.prototype.slice.call(this.attributes).map(function (attr) {\n            return ' ' + attr.name + (attr.value ? '=\"' + attr.value + '\"' : '');\n          }).join('');\n          return '<' + name + attributes + '>' + this.innerHTML + '</' + name + '>';\n        }\n      },\n      removeChild: {\n        value: function value(refNode) {\n          var ln = lightNodes.get(this);\n          var index = ln.indexOf(refNode);\n\n          if (index > -1) {\n            undistribute(refNode);\n            light.set(refNode, false);\n            parentNode.set(refNode, null);\n            ln.splice(index, 1);\n          }\n\n          return refNode;\n        }\n      },\n      replaceChild: {\n        value: function value(newNode, refNode) {\n          this.insertBefore(newNode, refNode);\n          return this.removeChild(refNode);\n        }\n      },\n      textContent: {\n        get: function get() {\n          return this.childNodes.map(function (node) {\n            return node.textContent;\n          }).join('');\n        },\n        set: function set(textContent) {\n          while (this.hasChildNodes()) {\n            this.removeChild(this.firstChild);\n          }\n          this.appendChild(document.createTextNode(textContent));\n        }\n      }\n    };\n\n    function polyfill$1 (host) {\n      if (polyfilled$2.get(host)) {\n        return;\n      }\n      lightNodes.set(host, makeLikeNodeList([]));\n      Object.defineProperties(host, members$1);\n      polyfilled$2.set(host, true);\n      return host;\n    }\n\n    var index$1 = __commonjs(function (module) {\n    module.exports = Date.now || now;\n\n    function now() {\n        return new Date().getTime();\n    }\n    });\n\n    var require$$0 = (index$1 && typeof index$1 === 'object' && 'default' in index$1 ? index$1['default'] : index$1);\n\n    var index = __commonjs(function (module) {\n    /**\n     * Module dependencies.\n     */\n\n    var now = require$$0;\n\n    /**\n     * Returns a function, that, as long as it continues to be invoked, will not\n     * be triggered. The function will be called after it stops being called for\n     * N milliseconds. If `immediate` is passed, trigger the function on the\n     * leading edge, instead of the trailing.\n     *\n     * @source underscore.js\n     * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n     * @param {Function} function to wrap\n     * @param {Number} timeout in ms (`100`)\n     * @param {Boolean} whether to execute at the beginning (`false`)\n     * @api public\n     */\n\n    module.exports = function debounce(func, wait, immediate) {\n      var timeout, args, context, timestamp, result;\n      if (null == wait) wait = 100;\n\n      function later() {\n        var last = now() - timestamp;\n\n        if (last < wait && last > 0) {\n          timeout = setTimeout(later, wait - last);\n        } else {\n          timeout = null;\n          if (!immediate) {\n            result = func.apply(context, args);\n            if (!timeout) context = args = null;\n          }\n        }\n      };\n\n      return function debounced() {\n        context = this;\n        args = arguments;\n        timestamp = now();\n        var callNow = immediate && !timeout;\n        if (!timeout) timeout = setTimeout(later, wait);\n        if (callNow) {\n          result = func.apply(context, args);\n          context = args = null;\n        }\n\n        return result;\n      };\n    };\n    });\n\n    var debounce = (index && typeof index === 'object' && 'default' in index ? index['default'] : index);\n\n    function getInitialFallbackContent(slot) {\n      var arr = [];\n      var chs = slot.childNodes;\n      var chsLen = chs.length;\n      for (var a = 0; a < chsLen; a++) {\n        arr.push(chs[a]);\n      }\n      return arr;\n    }\n\n    function getAssignedNodesDeep(slot) {\n      return assignedNodes.get(slot);\n    }\n\n    function shouldAffectSlot$1(slot) {\n      return fallbackState.get(slot);\n    }\n\n    function triggerSlotChangeEvent(slot) {\n      slot.dispatchEvent(new CustomEvent('slotchange', {\n        bubbles: false,\n        cancelable: false\n      }));\n    }\n\n    var members$2 = {\n      appendChild: {\n        value: function value(newNode) {\n          shouldAffectSlot$1(this) && appendChild.call(this, newNode);\n          this.childNodes.push(newNode);\n          return newNode;\n        }\n      },\n      childElementCount: {\n        get: function get() {\n          return this.children.length;\n        }\n      },\n      childNodes: {\n        get: function get() {\n          return fallbackNodes.get(this);\n        }\n      },\n      children: {\n        get: function get() {\n          return this.childNodes.filter(function (node) {\n            return node.nodeType === 1;\n          });\n        }\n      },\n      firstChild: {\n        get: function get() {\n          return this.childNodes[0] || null;\n        }\n      },\n      firstElementChild: {\n        get: function get() {\n          return this.children[0] || null;\n        }\n      },\n      getAssignedNodes: {\n        value: function value() {\n          var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n          return opts.deep ? getAssignedNodesDeep(this) : assignedNodes.get(this);\n        }\n      },\n      hasChildNodes: {\n        value: function value() {\n          return !!this.childNodes.length;\n        }\n      },\n      innerHTML: {\n        get: function get() {\n          return fallbackNodes.get(this).map(function (node) {\n            return node.outerHTML;\n          }).join('');\n        },\n        set: function set(innerHTML) {\n          fallbackNodes.set(this, []);\n          var chs = fragFromHtml(innerHTML).childNodes;\n          var chsLen = chs.length;\n          for (var a = chsLen - 1; a >= 0; a--) {\n            this.insertBefore(chs[a], this.firstChild);\n          }\n        }\n      },\n      insertBefore: {\n        value: function value(newNode, refNode) {\n          var fb = fallbackNodes.get(this);\n          shouldAffectSlot$1(this) && insertBefore.call(this, newNode, refNode);\n          fb.splice(fb.indexOf(refNode), 0, newNode);\n          return newNode;\n        }\n      },\n      lastChild: {\n        get: function get() {\n          var chs = this.childNodes;\n          return chs[chs.length - 1] || null;\n        }\n      },\n      lastElementChild: {\n        get: function get() {\n          var chs = this.children;\n          return chs[chs.length - 1] || null;\n        }\n      },\n      name: {\n        get: function get() {\n          return this.getAttribute('name');\n        },\n        set: function set(name) {\n          this.setAttribute('name', name);\n        }\n      },\n      outerHTML: {\n        get: function get() {\n          var attrs = this.attributes;\n          var tag = this.tagName.toLowerCase();\n          var str = '<' + tag;\n          if (attrs) {\n            var attrsLen = attrs.length;\n            for (var a = 0; a < attrsLen; a++) {\n              var attr = attrs[a];\n              str += ' ' + (attr.nodeName || attr.name) + '=\"' + attr.nodeValue + '\"';\n            }\n          }\n          return str + '>' + this.innerHTML + ('</' + tag + '>');\n        }\n      },\n      removeChild: {\n        value: function value(refNode) {\n          var fb = fallbackNodes.get(this);\n          shouldAffectSlot$1(this) && removeChild.call(this, refNode);\n          fb.splice(fb.indexOf(refNode), 1);\n          return refNode;\n        }\n      },\n      replaceChild: {\n        value: function value(newNode, refNode) {\n          var fb = fallbackNodes.get(this);\n          shouldAffectSlot$1(this) && replaceChild.call(this, newNode, refNode);\n          fb.splice(fb.indexOf(refNode), 1, newNode);\n          return refNode;\n        }\n      },\n      textContent: {\n        get: function get() {\n          return fallbackNodes.get(this).map(function (node) {\n            return node.textContent;\n          }).join('');\n        },\n        set: function set(textContent) {\n          fallbackNodes.set(this, [document.createTextNode(textContent)]);\n        }\n      }\n    };\n\n    function polyfill$2(slot) {\n      assignedNodes.set(slot, []);\n      fallbackNodes.set(slot, getInitialFallbackContent(slot));\n      fallbackState.set(slot, true);\n      debouncedTriggerSlotChangeEvent.set(slot, debounce(triggerSlotChangeEvent));\n      Object.defineProperties(slot, members$2);\n    }\n\n    function slotPolyfill (slot) {\n      if (polyfilled$1.get(slot)) {\n        return slot;\n      }\n      polyfill$2(slot);\n      polyfilled$1.set(slot, true);\n      return slot;\n    }\n\n    // Returns a document fragment of the childNodes of the specified element. Due\n    // to the nature of the DOM, this will remove the nodes from the element.\n    function createFragmentFromChildNodes(elem) {\n      var frag = document.createDocumentFragment();\n      while (elem.hasChildNodes()) {\n        frag.appendChild(elem.firstChild);\n      }\n      return frag;\n    }\n\n    // Creates an shadow root, appends it to the element and returns it.\n    function createShadowRoot(elem) {\n      var root = document.createElement(isBlockLevel(elem) ? 'div' : 'span');\n      elem.appendChild(root);\n      return root;\n    }\n\n    // Returns whether or not the specified element is a block level element or not\n    // We need this to determine the type of element the shadow root should be\n    // since we must use real nodes to simulate a shadow root.\n    function isBlockLevel(elem) {\n      return window.getComputedStyle(elem).display === 'block';\n    }\n\n    // Takes the shadow root and caches the slots it has.\n    function cacheSlots(root, node) {\n      var oldSlots = slots.get(root);\n      if (node.tagName === 'SLOT') {\n        slotPolyfill(node);\n        oldSlots[node.name || 'default'] = node;\n\n        var host = hosts.get(root);\n        var hostChs = host.childNodes;\n        var hostChsLen = hostChs.length;\n        for (var a = 0; a < hostChsLen; a++) {\n          var ch = hostChs[a];\n          if (!ch.assignedSlot) {\n            distribute(ch);\n          }\n        }\n      } else {\n        var newSlots = node.querySelectorAll('slot');\n        var newSlotsLen = newSlots.length;\n        for (var a = 0; a < newSlotsLen; a++) {\n          cacheSlots(root, newSlots[a]);\n        }\n      }\n    }\n\n    function uncacheSlots(root, node) {\n      var oldSlots = slots.get(root);\n      if (node.tagName === 'SLOT') {\n        node.getAssignedNodes().forEach(function (aNode) {\n          return undistribute(aNode);\n        });\n        delete oldSlots[node.name || 'default'];\n      } else if (node.nodeType === 1) {\n        var newSlots = node.querySelectorAll('slot');\n        var newSlotsLen = newSlots.length;\n        for (var a = 0; a < newSlotsLen; a++) {\n          uncacheSlots(root, newSlots[a]);\n        }\n      }\n    }\n\n    var members = {\n      appendChild: {\n        configurable: true,\n        value: function value(newNode) {\n          var ret = appendChild.call(this, newNode);\n          cacheSlots(this, newNode);\n          return ret;\n        }\n      },\n      host: {\n        configurable: true,\n        get: function get() {\n          return hosts.get(this);\n        }\n      },\n      innerHTML: {\n        configurable: true,\n        get: function get() {\n          return htmlFromFrag(this);\n        },\n        set: function set(innerHTML) {\n          var frag = fragFromHtml(innerHTML);\n          while (frag.hasChildNodes()) {\n            this.appendChild(frag.firstChild);\n          }\n        }\n      },\n      insertBefore: {\n        configurable: true,\n        value: function value(newNode, refNode) {\n          var ret = insertBefore.call(this, newNode, refNode);\n          cacheSlots(this, newNode);\n          return ret;\n        }\n      },\n      removeChild: {\n        configurable: true,\n        value: function value(refNode) {\n          var ret = removeChild.call(this, refNode);\n          uncacheSlots(this, refNode);\n          return ret;\n        }\n      },\n      replaceChild: {\n        configurable: true,\n        value: function value(newNode, refNode) {\n          var ret = replaceChild.call(this, newNode, refNode);\n          cacheSlots(this, newNode);\n          uncacheSlots(this, refNode);\n          return ret;\n        }\n      }\n    };\n\n    function polyfill (host) {\n      var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      var mode = _ref.mode;\n\n      if (host.shadowRoot) {\n        return host.shadowRoot;\n      }\n\n      var shadowRoot = createShadowRoot(host);\n      var initialLightDom = createFragmentFromChildNodes(host);\n\n      // Host and shadow root data.\n      hosts.set(shadowRoot, host);\n      roots.set(host, shadowRoot);\n      slots.set(shadowRoot, {});\n\n      // Emulating the spec { mode }.\n      Object.defineProperty(host, 'shadowRoot', {\n        configurable: true,\n        get: function get() {\n          return mode === 'open' ? shadowRoot : null;\n        }\n      });\n\n      // The shadow root is actually the only child of the host.\n      host.appendChild(shadowRoot);\n\n      // Now polyfill the shadow root so that we can cache slots.\n      Object.defineProperties(shadowRoot, members);\n\n      // Polyfill the host.\n      polyfill$1(host);\n\n      // Finally, insert the initial light DOM content so it's distributed.\n      host.appendChild(initialLightDom);\n\n      return shadowRoot;\n    }\n\n    // Returns a document fragment of the childNodes of the specified element. Due\n    // to the nature of the DOM, this will remove the nodes from the element.\n    function createFragmentFromChildNodes$1(elem) {\n      var frag = document.createDocumentFragment();\n      while (elem.hasChildNodes()) {\n        frag.appendChild(elem.firstChild);\n      }\n      return frag;\n    }\n\n    // Creates an shadow root, appends it to the element and returns it.\n    function createShadowRoot$1(elem) {\n      var root = document.createElement(isBlockLevel$1(elem) ? 'div' : 'span');\n      elem.appendChild(root);\n      return root;\n    }\n\n    // Returns whether or not the specified element is a block level element or not\n    // We need this to determine the type of element the shadow root should be\n    // since we must use real nodes to simulate a shadow root.\n    function isBlockLevel$1(elem) {\n      return window.getComputedStyle(elem).display === 'block';\n    }\n\n    // Simple renderer that proxies another renderer. It will polyfill if not yet\n    // polyfilled, or simply run the renderer. Initial content is taken into\n    // consideration.\n    var defaults = { shadowId: '' };\n    function render (fn) {\n      var opts = arguments.length <= 1 || arguments[1] === undefined ? defaults : arguments[1];\n\n      return function (elem) {\n        var shadowRoot = elem.__shadowRoot;\n\n        if (shadowRoot) {\n          fn(elem, shadowRoot);\n        } else {\n          // We get a fragment of the initial DOM so that we can create the shadow\n          // root.\n          var initialLightDom = createFragmentFromChildNodes$1(elem);\n\n          // Create a shadow ID so that it can be used to get a slot that is unique\n          // to this shadow root. Since we don't polyfill querySelector() et al, we\n          // need a way to be able to refer to slots that are unique to this\n          // shadow root.\n          elem.__shadowId = opts.shadowId;\n\n          // Create the shadow root and return the light DOM. We must get the light\n          // DOM before we template it so that we can distribute it after\n          // polyfilling.\n          elem.__shadowRoot = createShadowRoot$1(elem);\n\n          // Render once we have the initial light DOM as this would likely blow\n          // that away.\n          fn(elem, elem.__shadowRoot);\n\n          // Now polyfill so that we can distribute after.\n          polyfill$1(elem);\n\n          // Distribute the initial light DOM after polyfill so they get put into\n          // the right spots.\n          elem.appendChild(initialLightDom);\n        }\n      };\n    }\n\n    var version = '0.0.1';\n\n    Element.prototype.attachShadow = function (opts) {\n      return polyfill(this, opts);\n    };\n\n\n\n    var api = Object.freeze({\n      default: polyfill,\n      render: render,\n      version: version\n    });\n\n    var previousGlobal = window.skatejsNamedSlots;\n    polyfill.noConflict = function noConflict() {\n      window.skatejsNamedSlots = previousGlobal;\n      return this;\n    };\n    window.skatejsNamedSlots = polyfill;\n    for (var name in api) {\n      polyfill[name] = api[name];\n    }\n\n    return polyfill;\n\n}));\n//# sourceMappingURL=index.js.map"],"sourceRoot":"/source/"}