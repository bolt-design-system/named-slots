{"version":3,"sources":["index.min.js"],"names":["global","factory","exports","module","define","amd","skatejsNamedSlots","this","__commonjs","fn","shouldAffectSlot","slot","fallbackState","get","toggle","aNodes","assignedNodes","length","fNodes","fallbackNodes","forEach","node","removeChild","call","appendChild","set","triggerEvent","changeListeners","debouncedTriggerSlotChangeEvent","triggerSideEffects","getSlotName","getAttribute","getSlotNode","root","slots","distribute","host","parentNode","roots","an","ns","nextSibling","shouldManip","assignedSlot","splice","indexOf","insertBefore","push","undistribute","index","fragFromHtml","html","frag","document","createElement","innerHTML","htmlFromFrag","chs","childNodes","chsLen","a","outerHTML","each","func","DocumentFragment","polyfill$2","light","polyfilled","canPatchNativeAccessors","Object","defineProperties","members$3","arrayItem","idx","makeLikeNodeList","arr","item","cleanNode","parent","hostPolyfill","polyfilled$2","lightNodes","members$1","getInitialFallbackContent","getAssignedNodesDeep","shouldAffectSlot$1","triggerSlotChangeEvent","dispatchEvent","CustomEvent","bubbles","cancelable","polyfill$1","debounce","members$2","slotPolyfill","polyfilled$1","createFragmentFromChildNodes","elem","createDocumentFragment","hasChildNodes","firstChild","cacheSlots","oldSlots","tagName","name","hosts","hostChs","hostChsLen","ch","newSlots","querySelectorAll","newSlotsLen","uncacheSlots","getAssignedNodes","aNode","nodeType","polyfill","_ref","arguments","undefined","mode","polyfillShadowRootTagName","existingShadowRoot","shadowRoot","defaultShadowRootTagName","initialLightDom","defineProperty","configurable","members","WeakMap","window","Wm","key","prototype","delete","obj","has","val","proto","Node","replaceChild","getOwnPropertyDescriptor","configurable$1","parentElement","__parentElement","__parentNode","parChs","parChsLen","__nextSibling","nextElementSibling","found","next","__nextElementSibling","previousSibling","__previousSibling","previousElementSibling","__previousElementSibling","nodeProto","elProto","Element","name$1","proto$2","hasOwnProperty","nativeDescriptor","newNode","refNode","value","ln","childElementCount","children","filter","firstElementChild","copy","lastChild","lastElementChild","toLowerCase","attributes","Array","slice","map","attr","join","textContent","createTextNode","index$1","now","Date","getTime","require$$0","wait","immediate","later","last","timestamp","timeout","setTimeout","result","apply","context","args","callNow","opts","deep","fb","setAttribute","attrs","tag","str","attrsLen","nodeName","nodeValue","ret","version","api","freeze","default","previousGlobal","noConflict"],"mappings":"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","file":"index.min.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global.skatejsNamedSlots = factory());\n}(this, function () {\n\n    function __commonjs(fn, module) { return module = { exports: {} }, fn(module, module.exports), module.exports; }\n\n    var WeakMap = window.WeakMap || function () {\n      var index = 0;\n      function Wm() {\n        this.key = '____weak_map_' + index++;\n      }\n      Wm.prototype = {\n        delete: function _delete(obj) {\n          delete obj[this.key];\n        },\n        get: function get(obj) {\n          return obj[this.key];\n        },\n        has: function has(obj) {\n          return typeof obj[this.key] !== 'undefined';\n        },\n        set: function set(obj, val) {\n          return obj[this.key] = val;\n        }\n      };\n      return Wm;\n    }();\n\n    var hosts = new WeakMap();\n    var roots = new WeakMap();\n    var slots = new WeakMap();\n\n    var proto = Node.prototype;\n    var appendChild = proto.appendChild;\n    var insertBefore = proto.insertBefore;\n    var removeChild = proto.removeChild;\n    var replaceChild = proto.replaceChild;\n\n    var assignedSlot = new WeakMap();\n    var light = new WeakMap();\n    var parentNode = new WeakMap();\n    var polyfilled = new WeakMap();\n\n    var assignedNodes = new WeakMap();\n    var changeListeners = new WeakMap();\n    var debouncedTriggerSlotChangeEvent = new WeakMap();\n    var fallbackNodes = new WeakMap();\n    var fallbackState = new WeakMap();\n    var polyfilled$1 = new WeakMap();\n\n    function shouldAffectSlot(slot) {\n      return !fallbackState.get(slot);\n    }\n\n    function toggle(slot) {\n      if (fallbackState.get(slot)) {\n        var aNodes = assignedNodes.get(slot);\n        if (aNodes.length) {\n          var fNodes = fallbackNodes.get(slot);\n          fNodes.forEach(function (node) {\n            return removeChild.call(slot, node);\n          });\n          aNodes.forEach(function (node) {\n            return appendChild.call(slot, node);\n          });\n          fallbackState.set(slot, false);\n        }\n      } else {\n        var aNodes = assignedNodes.get(slot);\n        if (!aNodes.length) {\n          var fNodes = fallbackNodes.get(slot);\n          aNodes.forEach(function (node) {\n            return removeChild.call(slot, node);\n          });\n          fNodes.forEach(function (node) {\n            return appendChild.call(slot, node);\n          });\n          fallbackState.set(slot, true);\n        }\n      }\n    }\n\n    function triggerEvent(slot) {\n      if (changeListeners.get(slot)) {\n        debouncedTriggerSlotChangeEvent.get(slot)(slot);\n      }\n    }\n\n    function triggerSideEffects(slot) {\n      toggle(slot);\n      triggerEvent(slot);\n    }\n\n    function getSlotName(node) {\n      return (node.getAttribute ? node.getAttribute('slot') : null) || 'default';\n    }\n\n    function getSlotNode(root, node) {\n      var slot = getSlotName(node);\n      return slots.get(root)[slot];\n    }\n\n    function distribute (node) {\n      var host = node.parentNode;\n      var slot = getSlotNode(roots.get(host), node);\n\n      if (slot) {\n        var an = assignedNodes.get(slot);\n        var ns = node.nextSibling;\n        var shouldManip = shouldAffectSlot(slot);\n\n        assignedSlot.set(node, slot);\n\n        if (ns && ns.assignedSlot === slot) {\n          an.splice(an.indexOf(ns), 0, node);\n          shouldManip && insertBefore.call(slot, node, ns);\n        } else {\n          an.push(node);\n          shouldManip && appendChild.call(slot, node);\n        }\n\n        triggerSideEffects(slot);\n      }\n    }\n\n    function undistribute(node) {\n      var host = node.parentNode;\n      var slot = getSlotNode(roots.get(host), node);\n\n      if (slot) {\n        var an = assignedNodes.get(slot);\n        var index = an.indexOf(node);\n\n        if (index > -1) {\n          shouldAffectSlot(slot) && removeChild.call(slot, node);\n          assignedSlot.set(node, null);\n          an.splice(index, 1);\n          triggerSideEffects(slot);\n        }\n      }\n    }\n\n    function fragFromHtml (html) {\n      var frag = document.createElement('div');\n      frag.innerHTML = html;\n      return frag;\n    }\n\n    function htmlFromFrag (frag) {\n      var html = '';\n      var chs = frag.childNodes;\n      var chsLen = chs.length;\n      for (var a = 0; a < chsLen; a++) {\n        html += chs[a].outerHTML;\n      }\n      return html;\n    }\n\n    var lightNodes = new WeakMap();\n    var polyfilled$2 = new WeakMap();\n\n    // Does something for a single node or a DocumentFragment. This is useful when\n    // working with arguments that are passed to DOM methods that work with either.\n    function each (node, func) {\n      if (node instanceof DocumentFragment) {\n        var chs = node.childNodes;\n        var chsLen = chs.length;\n        for (var a = 0; a < chsLen; a++) {\n          func(chs[a]);\n        }\n      } else {\n        func(node);\n      }\n    }\n\n    // Any code referring to this is because it has to work around this bug in\n    // WebKit: https://bugs.webkit.org/show_bug.cgi?id=49739\n    var canPatchNativeAccessors = !!Object.getOwnPropertyDescriptor(Node.prototype, 'parentNode').get;\n\n    var configurable$1 = true;\n    var members$3 = {\n      assignedSlot: {\n        configurable: configurable$1,\n        get: function get() {\n          return assignedSlot.get(this) || null;\n        }\n      },\n      parentElement: {\n        configurable: configurable$1,\n        get: function get() {\n          if (light.get(this)) {\n            var parent = this.parentNode;\n            return parent.nodeType === 1 ? parent : null;\n          }\n          return this.__parentElement;\n        }\n      },\n      parentNode: {\n        configurable: configurable$1,\n        get: function get() {\n          return parentNode.get(this) || this.__parentNode || null;\n        }\n      },\n      nextSibling: {\n        configurable: configurable$1,\n        get: function get() {\n          if (light.get(this)) {\n            var parChs = this.parentNode.childNodes;\n            var parChsLen = parChs.length;\n            for (var a = 0; a < parChsLen; a++) {\n              if (parChs[a] === this) {\n                return parChs[a + 1] || null;\n              }\n            }\n          }\n          return this.__nextSibling;\n        }\n      },\n      nextElementSibling: {\n        configurable: configurable$1,\n        get: function get() {\n          if (light.get(this)) {\n            var parChs = this.parentNode.childNodes;\n            var parChsLen = parChs.length;\n\n            var found = false;\n            for (var a = 0; a < parChsLen; a++) {\n              if (!found && parChs[a] === this) {\n                found = true;\n              }\n\n              if (!found) {\n                continue;\n              }\n\n              var next = parChs[a + 1];\n              if (next && next.nodeType === 1) {\n                return next;\n              } else {\n                continue;\n              }\n            }\n          }\n          return this.__nextElementSibling;\n        }\n      },\n      previousSibling: {\n        configurable: configurable$1,\n        get: function get() {\n          if (light.get(this)) {\n            var parChs = this.parentNode.childNodes;\n            var parChsLen = parChs.length;\n            for (var a = parChsLen - 1; a >= 0; a--) {\n              if (parChs[a] === this) {\n                return parChs[a - 1] || null;\n              }\n            }\n          }\n          return this.__previousSibling;\n        }\n      },\n      previousElementSibling: {\n        configurable: configurable$1,\n        get: function get() {\n          if (light.get(this)) {\n            var parChs = this.parentNode.childNodes;\n            var parChsLen = parChs.length;\n\n            var found = false;\n            for (var a = parChsLen - 1; a >= 0; a--) {\n              if (!found && parChs[a] === this) {\n                found = true;\n              }\n\n              if (!found) {\n                continue;\n              }\n\n              var next = parChs[a - 1];\n              if (next && next.nodeType === 1) {\n                return next;\n              } else {\n                continue;\n              }\n            }\n          }\n          return this.__previousElementSibling;\n        }\n      }\n    };\n\n    // If we can patch native accessors, we can safely apply light DOM accessors to\n    // all HTML elements. This is faster than polyfilling them individually as they\n    // are added, if possible, and doesn't have a measurable impact on performance\n    // when they're not marked as light DOM.\n    var nodeProto = Node.prototype;\n    var elProto = Element.prototype;\n    if (canPatchNativeAccessors) {\n      for (var name$1 in members$3) {\n        var proto$2 = nodeProto.hasOwnProperty(name$1) ? nodeProto : elProto;\n        var nativeDescriptor = Object.getOwnPropertyDescriptor(proto$2, name$1);\n        if (nativeDescriptor) {\n          Object.defineProperty(proto$2, '__' + name$1, nativeDescriptor);\n        }\n        Object.defineProperty(proto$2, name$1, members$3[name$1]);\n      }\n    }\n\n    // We patch the node prototype to ensure any method that reparents a node\n    // cleans up after the polyfills.\n    nodeProto.appendChild = function (newNode) {\n      if (polyfilled.get(newNode)) {\n        assignedSlot.set(newNode, null);\n        light.set(newNode, false);\n        parentNode.set(newNode, this);\n      }\n      return appendChild.call(this, newNode);\n    };\n    nodeProto.insertBefore = function (newNode, refNode) {\n      if (polyfilled.get(newNode)) {\n        assignedSlot.set(newNode, null);\n        light.set(newNode, false);\n        parentNode.set(newNode, this);\n      }\n      return insertBefore.call(this, newNode, refNode);\n    };\n    nodeProto.removeChild = function (refNode) {\n      if (polyfilled.get(refNode)) {\n        assignedSlot.set(refNode, null);\n        light.set(refNode, false);\n        parentNode.set(refNode, null);\n      }\n      return removeChild.call(this, refNode);\n    };\n    nodeProto.replaceChild = function (newNode, refNode) {\n      if (polyfilled.get(newNode)) {\n        assignedSlot.set(newNode, null);\n        light.set(newNode, false);\n        parentNode.set(newNode, this);\n      }\n      if (polyfilled.get(refNode)) {\n        assignedSlot.set(refNode, null);\n        light.set(refNode, false);\n        parentNode.set(refNode, null);\n      }\n      return replaceChild.call(this, newNode, refNode);\n    };\n\n    // By default we should always return null from the Element for `assignedSlot`.\n    Object.defineProperty(nodeProto, 'assignedSlot', {\n      configurable: configurable$1,\n      get: function get() {\n        return null;\n      }\n    });\n\n    function polyfill$2(light) {\n      if (polyfilled.get(light)) {\n        return;\n      }\n      polyfilled.set(light, true);\n      if (!canPatchNativeAccessors) {\n        Object.defineProperties(light, members$3);\n      }\n    }\n\n    var configurable = true;\n\n    // Slotting helpers.\n\n    function arrayItem(idx) {\n      return this[idx];\n    }\n\n    function makeLikeNodeList(arr) {\n      arr.item = arrayItem;\n      return arr;\n    }\n\n    // If we append a child to a host, the host tells the shadow root to distribute\n    // it. If the root decides it doesn't need to be distributed, it is never\n    // removed from the old parent because in polyfill land we store a reference\n    // to the node but we don't move it. Due to that, we must explicitly remove the\n    // node from its old parent.\n    function cleanNode(node) {\n      var parent = node.parentNode;\n      if (parent) {\n        parent.removeChild(node);\n      }\n    }\n\n    var members$1 = {\n      appendChild: {\n        value: function value(newNode) {\n          var ln = lightNodes.get(this);\n          var host = this;\n          cleanNode(newNode);\n          each(newNode, function (node) {\n            ln.push(node);\n            light.set(node, true);\n            parentNode.set(node, host);\n            polyfill$2(node);\n            distribute(node);\n          });\n          return newNode;\n        }\n      },\n      childElementCount: {\n        configurable: configurable,\n        get: function get() {\n          return this.children.length;\n        }\n      },\n      childNodes: {\n        get: function get() {\n          return lightNodes.get(this);\n        }\n      },\n      children: {\n        get: function get() {\n          return makeLikeNodeList(this.childNodes.filter(function (node) {\n            return node.nodeType === 1;\n          }));\n        }\n      },\n      firstChild: {\n        get: function get() {\n          return this.childNodes[0] || null;\n        }\n      },\n      firstElementChild: {\n        get: function get() {\n          return this.children[0] || null;\n        }\n      },\n      hasChildNodes: {\n        value: function value() {\n          return this.childNodes.length > 0;\n        }\n      },\n      innerHTML: {\n        get: function get() {\n          return htmlFromFrag(this);\n        },\n        set: function set(innerHTML) {\n          var copy = fragFromHtml(innerHTML);\n          while (this.hasChildNodes()) {\n            this.removeChild(this.firstChild);\n          }\n          while (copy.hasChildNodes()) {\n            this.appendChild(copy.firstChild);\n          }\n        }\n      },\n      insertBefore: {\n        value: function value(newNode, refNode) {\n          var ln = lightNodes.get(this);\n          var host = this;\n          cleanNode(newNode);\n          each(newNode, function (node) {\n            var index = ln.indexOf(refNode);\n            if (index > -1) {\n              ln.splice(index, 0, node);\n            } else {\n              ln.push(node);\n            }\n            light.set(node, true);\n            parentNode.set(node, host);\n            polyfill$2(node);\n            distribute(node);\n          });\n          return newNode;\n        }\n      },\n      lastChild: {\n        get: function get() {\n          var ch = this.childNodes;\n          return ch[ch.length - 1] || null;\n        }\n      },\n      lastElementChild: {\n        get: function get() {\n          var ch = this.children;\n          return ch[ch.length - 1] || null;\n        }\n      },\n      outerHTML: {\n        get: function get() {\n          var name = this.tagName.toLowerCase();\n          var attributes = Array.prototype.slice.call(this.attributes).map(function (attr) {\n            return ' ' + attr.name + (attr.value ? '=\"' + attr.value + '\"' : '');\n          }).join('');\n          return '<' + name + attributes + '>' + this.innerHTML + '</' + name + '>';\n        }\n      },\n      removeChild: {\n        value: function value(refNode) {\n          var ln = lightNodes.get(this);\n          var index = ln.indexOf(refNode);\n\n          if (index > -1) {\n            undistribute(refNode);\n            light.set(refNode, false);\n            parentNode.set(refNode, null);\n            ln.splice(index, 1);\n          }\n\n          return refNode;\n        }\n      },\n      replaceChild: {\n        value: function value(newNode, refNode) {\n          this.insertBefore(newNode, refNode);\n          return this.removeChild(refNode);\n        }\n      },\n      textContent: {\n        get: function get() {\n          return this.childNodes.map(function (node) {\n            return node.textContent;\n          }).join('');\n        },\n        set: function set(textContent) {\n          while (this.hasChildNodes()) {\n            this.removeChild(this.firstChild);\n          }\n          this.appendChild(document.createTextNode(textContent));\n        }\n      }\n    };\n\n    function hostPolyfill (host) {\n      if (polyfilled$2.get(host)) {\n        return;\n      }\n      lightNodes.set(host, makeLikeNodeList([]));\n      Object.defineProperties(host, members$1);\n      polyfilled$2.set(host, true);\n      return host;\n    }\n\n    var index$1 = __commonjs(function (module) {\n    module.exports = Date.now || now;\n\n    function now() {\n        return new Date().getTime();\n    }\n    });\n\n    var require$$0 = (index$1 && typeof index$1 === 'object' && 'default' in index$1 ? index$1['default'] : index$1);\n\n    var index = __commonjs(function (module) {\n    /**\n     * Module dependencies.\n     */\n\n    var now = require$$0;\n\n    /**\n     * Returns a function, that, as long as it continues to be invoked, will not\n     * be triggered. The function will be called after it stops being called for\n     * N milliseconds. If `immediate` is passed, trigger the function on the\n     * leading edge, instead of the trailing.\n     *\n     * @source underscore.js\n     * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n     * @param {Function} function to wrap\n     * @param {Number} timeout in ms (`100`)\n     * @param {Boolean} whether to execute at the beginning (`false`)\n     * @api public\n     */\n\n    module.exports = function debounce(func, wait, immediate) {\n      var timeout, args, context, timestamp, result;\n      if (null == wait) wait = 100;\n\n      function later() {\n        var last = now() - timestamp;\n\n        if (last < wait && last > 0) {\n          timeout = setTimeout(later, wait - last);\n        } else {\n          timeout = null;\n          if (!immediate) {\n            result = func.apply(context, args);\n            if (!timeout) context = args = null;\n          }\n        }\n      };\n\n      return function debounced() {\n        context = this;\n        args = arguments;\n        timestamp = now();\n        var callNow = immediate && !timeout;\n        if (!timeout) timeout = setTimeout(later, wait);\n        if (callNow) {\n          result = func.apply(context, args);\n          context = args = null;\n        }\n\n        return result;\n      };\n    };\n    });\n\n    var debounce = (index && typeof index === 'object' && 'default' in index ? index['default'] : index);\n\n    function getInitialFallbackContent(slot) {\n      var arr = [];\n      var chs = slot.childNodes;\n      var chsLen = chs.length;\n      for (var a = 0; a < chsLen; a++) {\n        arr.push(chs[a]);\n      }\n      return arr;\n    }\n\n    function getAssignedNodesDeep(slot) {\n      return assignedNodes.get(slot);\n    }\n\n    function shouldAffectSlot$1(slot) {\n      return fallbackState.get(slot);\n    }\n\n    function triggerSlotChangeEvent(slot) {\n      slot.dispatchEvent(new CustomEvent('slotchange', {\n        bubbles: false,\n        cancelable: false\n      }));\n    }\n\n    var members$2 = {\n      appendChild: {\n        value: function value(newNode) {\n          shouldAffectSlot$1(this) && appendChild.call(this, newNode);\n          this.childNodes.push(newNode);\n          return newNode;\n        }\n      },\n      childElementCount: {\n        get: function get() {\n          return this.children.length;\n        }\n      },\n      childNodes: {\n        get: function get() {\n          return fallbackNodes.get(this);\n        }\n      },\n      children: {\n        get: function get() {\n          return this.childNodes.filter(function (node) {\n            return node.nodeType === 1;\n          });\n        }\n      },\n      firstChild: {\n        get: function get() {\n          return this.childNodes[0] || null;\n        }\n      },\n      firstElementChild: {\n        get: function get() {\n          return this.children[0] || null;\n        }\n      },\n      getAssignedNodes: {\n        value: function value() {\n          var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n          return opts.deep ? getAssignedNodesDeep(this) : assignedNodes.get(this);\n        }\n      },\n      hasChildNodes: {\n        value: function value() {\n          return !!this.childNodes.length;\n        }\n      },\n      innerHTML: {\n        get: function get() {\n          return fallbackNodes.get(this).map(function (node) {\n            return node.outerHTML;\n          }).join('');\n        },\n        set: function set(innerHTML) {\n          fallbackNodes.set(this, []);\n          var chs = fragFromHtml(innerHTML).childNodes;\n          var chsLen = chs.length;\n          for (var a = chsLen - 1; a >= 0; a--) {\n            this.insertBefore(chs[a], this.firstChild);\n          }\n        }\n      },\n      insertBefore: {\n        value: function value(newNode, refNode) {\n          var fb = fallbackNodes.get(this);\n          shouldAffectSlot$1(this) && insertBefore.call(this, newNode, refNode);\n          fb.splice(fb.indexOf(refNode), 0, newNode);\n          return newNode;\n        }\n      },\n      lastChild: {\n        get: function get() {\n          var chs = this.childNodes;\n          return chs[chs.length - 1] || null;\n        }\n      },\n      lastElementChild: {\n        get: function get() {\n          var chs = this.children;\n          return chs[chs.length - 1] || null;\n        }\n      },\n      name: {\n        get: function get() {\n          return this.getAttribute('name');\n        },\n        set: function set(name) {\n          this.setAttribute('name', name);\n        }\n      },\n      outerHTML: {\n        get: function get() {\n          var attrs = this.attributes;\n          var tag = this.tagName.toLowerCase();\n          var str = '<' + tag;\n          if (attrs) {\n            var attrsLen = attrs.length;\n            for (var a = 0; a < attrsLen; a++) {\n              var attr = attrs[a];\n              str += ' ' + (attr.nodeName || attr.name) + '=\"' + attr.nodeValue + '\"';\n            }\n          }\n          return str + '>' + this.innerHTML + ('</' + tag + '>');\n        }\n      },\n      removeChild: {\n        value: function value(refNode) {\n          var fb = fallbackNodes.get(this);\n          shouldAffectSlot$1(this) && removeChild.call(this, refNode);\n          fb.splice(fb.indexOf(refNode), 1);\n          return refNode;\n        }\n      },\n      replaceChild: {\n        value: function value(newNode, refNode) {\n          var fb = fallbackNodes.get(this);\n          shouldAffectSlot$1(this) && replaceChild.call(this, newNode, refNode);\n          fb.splice(fb.indexOf(refNode), 1, newNode);\n          return refNode;\n        }\n      },\n      textContent: {\n        get: function get() {\n          return fallbackNodes.get(this).map(function (node) {\n            return node.textContent;\n          }).join('');\n        },\n        set: function set(textContent) {\n          fallbackNodes.set(this, [document.createTextNode(textContent)]);\n        }\n      }\n    };\n\n    function polyfill$1(slot) {\n      assignedNodes.set(slot, []);\n      fallbackNodes.set(slot, getInitialFallbackContent(slot));\n      fallbackState.set(slot, true);\n      debouncedTriggerSlotChangeEvent.set(slot, debounce(triggerSlotChangeEvent));\n      Object.defineProperties(slot, members$2);\n    }\n\n    function slotPolyfill (slot) {\n      if (polyfilled$1.get(slot)) {\n        return slot;\n      }\n      polyfill$1(slot);\n      polyfilled$1.set(slot, true);\n      return slot;\n    }\n\n    var defaultShadowRootTagName = '_shadow_root_';\n\n    // Returns a document fragment of the childNodes of the specified element. Due\n    // to the nature of the DOM, this will remove the nodes from the element.\n    function createFragmentFromChildNodes(elem) {\n      var frag = document.createDocumentFragment();\n      while (elem.hasChildNodes()) {\n        frag.appendChild(elem.firstChild);\n      }\n      return frag;\n    }\n\n    // Takes the shadow root and caches the slots it has.\n    function cacheSlots(root, node) {\n      var oldSlots = slots.get(root);\n      if (node.tagName === 'SLOT') {\n        slotPolyfill(node);\n        oldSlots[node.name || 'default'] = node;\n\n        var host = hosts.get(root);\n        var hostChs = host.childNodes;\n        var hostChsLen = hostChs.length;\n        for (var a = 0; a < hostChsLen; a++) {\n          var ch = hostChs[a];\n          if (!ch.assignedSlot) {\n            distribute(ch);\n          }\n        }\n      } else {\n        var newSlots = node.querySelectorAll('slot');\n        var newSlotsLen = newSlots.length;\n        for (var a = 0; a < newSlotsLen; a++) {\n          cacheSlots(root, newSlots[a]);\n        }\n      }\n    }\n\n    function uncacheSlots(root, node) {\n      var oldSlots = slots.get(root);\n      if (node.tagName === 'SLOT') {\n        node.getAssignedNodes().forEach(function (aNode) {\n          return undistribute(aNode);\n        });\n        delete oldSlots[node.name || 'default'];\n      } else if (node.nodeType === 1) {\n        var newSlots = node.querySelectorAll('slot');\n        var newSlotsLen = newSlots.length;\n        for (var a = 0; a < newSlotsLen; a++) {\n          uncacheSlots(root, newSlots[a]);\n        }\n      }\n    }\n\n    var members = {\n      appendChild: {\n        configurable: true,\n        value: function value(newNode) {\n          var ret = appendChild.call(this, newNode);\n          cacheSlots(this, newNode);\n          return ret;\n        }\n      },\n      host: {\n        configurable: true,\n        get: function get() {\n          return hosts.get(this);\n        }\n      },\n      innerHTML: {\n        configurable: true,\n        get: function get() {\n          return htmlFromFrag(this);\n        },\n        set: function set(innerHTML) {\n          var frag = fragFromHtml(innerHTML);\n          while (frag.hasChildNodes()) {\n            this.appendChild(frag.firstChild);\n          }\n        }\n      },\n      insertBefore: {\n        configurable: true,\n        value: function value(newNode, refNode) {\n          var ret = insertBefore.call(this, newNode, refNode);\n          cacheSlots(this, newNode);\n          return ret;\n        }\n      },\n      removeChild: {\n        configurable: true,\n        value: function value(refNode) {\n          var ret = removeChild.call(this, refNode);\n          uncacheSlots(this, refNode);\n          return ret;\n        }\n      },\n      replaceChild: {\n        configurable: true,\n        value: function value(newNode, refNode) {\n          var ret = replaceChild.call(this, newNode, refNode);\n          cacheSlots(this, newNode);\n          uncacheSlots(this, refNode);\n          return ret;\n        }\n      }\n    };\n\n    function polyfill(host) {\n      var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      var mode = _ref.mode;\n      var polyfillShadowRootTagName = _ref.polyfillShadowRootTagName;\n\n      var existingShadowRoot = roots.get(host);\n\n      if (existingShadowRoot) {\n        return existingShadowRoot;\n      }\n\n      var shadowRoot = document.createElement(polyfillShadowRootTagName || defaultShadowRootTagName);\n      var initialLightDom = createFragmentFromChildNodes(host);\n\n      // Host and shadow root data.\n      hosts.set(shadowRoot, host);\n      roots.set(host, shadowRoot);\n      slots.set(shadowRoot, {});\n\n      // Emulating the spec { mode }.\n      Object.defineProperty(host, 'shadowRoot', {\n        configurable: true,\n        get: function get() {\n          return mode === 'open' ? shadowRoot : null;\n        }\n      });\n\n      // The shadow root is actually the only child of the host.\n      host.appendChild(shadowRoot);\n\n      // Now polyfill the shadow root so that we can cache slots.\n      Object.defineProperties(shadowRoot, members);\n\n      // Polyfill the host.\n      hostPolyfill(host);\n\n      // Finally, insert the initial light DOM content so it's distributed.\n      host.appendChild(initialLightDom);\n\n      return shadowRoot;\n    }\n\n    var version = '0.0.1';\n\n\n\n    var api = Object.freeze({\n    \tdefault: polyfill,\n    \tversion: version\n    });\n\n    var previousGlobal = window.skatejsNamedSlots;\n    polyfill.noConflict = function noConflict() {\n      window.skatejsNamedSlots = previousGlobal;\n      return this;\n    };\n    window.skatejsNamedSlots = polyfill;\n    for (var name in api) {\n      polyfill[name] = api[name];\n    }\n\n    return polyfill;\n\n}));\n//# sourceMappingURL=index.js.map"],"sourceRoot":"/source/"}