{"version":3,"sources":["index.min.js"],"names":["global","factory","exports","module","define","amd","skatejsNamedSlots","this","queryForNamedSlot","host","name","querySelector","queryForUnnamedSlot","getSlot","node","slotName","getAttribute","cacheKey","__slots","slots","_slotElement","parentNode","calculatedName","__shadowId","slotElement","applyParentNode","parent","__isLightDom","__polyfilledParentNode","canPatchNativeAccessors","Object","defineProperties","descendantAccessors","removeParentNode","arrayItem","idx","doForNodesIfSlot","elem","func","nodeToArray","forEach","slot","makeLikeNodeList","arr","item","DocumentFragment","toArray","childNodes","obj","Array","prototype","slice","call","polyfill","mapPolyfilled","get","props","prop","funcs","set","polyfilled","createFragmentFromChildNodes","frag","document","createDocumentFragment","hasChildNodes","appendChild","firstChild","createShadowRoot","root","createElement","isBlockLevel","window","getComputedStyle","display","render","fn","opts","arguments","length","undefined","defaults","shadowRoot","__shadowRoot","initialLightDom","shadowId","WeakMap","defineProperty","bind","configurable","elProto","Element","htmlElProto","HTMLElement","nodeProto","Node","descEl","getOwnPropertyDescriptor","descNode","__nextElementSibling","__nextSibling","__parentElement","__parentNode","__previousElementSibling","__previousSibling","parentElement","nodeType","nextSibling","index","parChs","parChsLen","a","nextElementSibling","next","previousSibling","previousElementSibling","prev","childElementCount","children","nodes","childNodesLen","push","filter","firstElementChild","innerHTML","map","outerHTML","textContent","join","val","div","removeChild","lastChild","ch","lastElementChild","tagName","toLowerCase","attributes","attr","value","toString","newNode","insertBefore","refNode","replaceChild","version","api","freeze","default","previousGlobal","noConflict"],"mappings":"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","file":"index.min.js","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.skatejsNamedSlots = factory());\n}(this, function () {\n\n  function queryForNamedSlot(host, name) {\n    return host.querySelector('slot[name=\"' + name + '\"], [slot-name=\"' + name + '\"]');\n  }\n\n  function queryForUnnamedSlot(host) {\n    return host.querySelector('slot[name=\"\"], slot:not([name]), [slot-name=\"\"]');\n  }\n\n  function getSlot (host, node) {\n    if (!node) {\n      return;\n    }\n\n    var slotName = node.getAttribute && node.getAttribute('slot');\n    var cacheKey = slotName || 'content';\n\n    if (!host.__slots) {\n      host.__slots = {};\n    }\n\n    var slots = host.__slots;\n\n    // We check for a cached slot first because querying is slow.\n    if (slots[cacheKey]) {\n      var _slotElement = slots[cacheKey];\n\n      // However, we check to see if it was detached. If not, just return it.\n      if (_slotElement.parentNode) {\n        return _slotElement;\n      }\n\n      // if it was detached we should make sure it's cleaned up.\n      delete slots[cacheKey];\n      return null;\n    }\n\n    var calculatedName = (host.__shadowId || '') + (slotName || '');\n    var slotElement = slotName ? queryForNamedSlot(host, calculatedName) : queryForUnnamedSlot(host);\n\n    // Cache it because querying is slow.\n    if (slotElement) {\n      slots[cacheKey] = slotElement;\n    }\n\n    return slots[cacheKey] || null;\n  }\n\n  var mapPolyfilled = new WeakMap();\n\n  var prop = Object.defineProperty.bind(Object);\n\n  var configurable = true;\n\n  // Cached prototypes.\n  var elProto = Element.prototype;\n  var htmlElProto = HTMLElement.prototype;\n  var nodeProto = Node.prototype;\n\n  // Cached descriptor getters.\n  var descEl = Object.getOwnPropertyDescriptor.bind(Object, elProto);\n  var descNode = Object.getOwnPropertyDescriptor.bind(Object, nodeProto);\n\n  // Properties that must be applied to descendants.\n  var descendantAccessors = {\n    // Natives.\n    __nextElementSibling: descEl('nextElementSibling'),\n    __nextSibling: descNode('nextSibling'),\n    __parentElement: descNode('parentElement'),\n    __parentNode: descNode('parentNode'),\n    __previousElementSibling: descEl('nextElementSibling'),\n    __previousSibling: descNode('previousSibling'),\n\n    // Polyfills.\n    parentElement: {\n      configurable: configurable,\n      get: function get() {\n        if (this.__isLightDom) {\n          var parent = this.parentNode;\n          return parent.nodeType === 1 ? parent : null;\n        }\n        return this.__parentElement;\n      }\n    },\n    parentNode: {\n      configurable: configurable,\n      get: function get() {\n        return this.__polyfilledParentNode || this.__parentNode || null;\n      }\n    },\n    nextSibling: {\n      configurable: configurable,\n      get: function get() {\n        if (this.__isLightDom) {\n          var index = undefined;\n          var parChs = this.parentNode.childNodes;\n          var parChsLen = parChs.length;\n          for (var a = 0; a < parChsLen; a++) {\n            if (parChs[a] === this) {\n              index = a;\n              continue;\n            }\n          }\n          return typeof index === 'number' ? parChs[index + 1] : null;\n        }\n        return this.__nextSibling;\n      }\n    },\n    nextElementSibling: {\n      configurable: configurable,\n      get: function get() {\n        if (this.__isLightDom) {\n          var next = undefined;\n          while (next = this.nextSibling) {\n            if (next.nodeType === 1) {\n              return next;\n            }\n          }\n          return null;\n        }\n        return this.__nextElementSibling;\n      }\n    },\n    previousSibling: {\n      configurable: configurable,\n      get: function get() {\n        if (this.__isLightDom) {\n          var index = undefined;\n          var parChs = this.parentNode.childNodes;\n          var parChsLen = parChs.length;\n          for (var a = 0; a < parChsLen; a++) {\n            if (parChs[a] === this) {\n              index = a;\n              continue;\n            }\n          }\n          return typeof index === 'number' ? parChs[index - 1] : null;\n        }\n        return this.__previousSibling;\n      }\n    },\n    previousElementSibling: {\n      configurable: configurable,\n      get: function get() {\n        if (this.__isLightDom) {\n          var prev = undefined;\n          while (prev = this.previousSibling) {\n            if (prev.nodeType === 1) {\n              return prev;\n            }\n          }\n          return null;\n        }\n        return this.__previousElementSibling;\n      }\n    }\n  };\n\n  // WebKit, this is because of you.\n  var canPatchNativeAccessors = !!descendantAccessors.__parentNode.get;\n\n  // Helpers.\n\n  function applyParentNode(node, parent) {\n    node.__isLightDom = true;\n    node.__polyfilledParentNode = parent;\n    if (!canPatchNativeAccessors) {\n      Object.defineProperties(node, descendantAccessors);\n    }\n  }\n\n  function removeParentNode(node) {\n    node.__isLightDom = false;\n    node.__polyfilledParentNode = null;\n  }\n\n  function arrayItem(idx) {\n    return this[idx];\n  }\n\n  function doForNodesIfSlot(elem, node, func) {\n    nodeToArray(node).forEach(function (node) {\n      var slot = getSlot(elem, node);\n      if (slot) {\n        func(elem, node, slot);\n      }\n    });\n  }\n\n  function makeLikeNodeList(arr) {\n    arr.item = arrayItem;\n    return arr;\n  }\n\n  function nodeToArray(node) {\n    return node instanceof DocumentFragment ? toArray(node.childNodes) : [node];\n  }\n\n  function toArray(obj) {\n    return Array.prototype.slice.call(obj);\n  }\n\n  // Prop overrides.\n\n  var props = {\n    childElementCount: {\n      get: function get() {\n        return this.children.length;\n      }\n    },\n    childNodes: {\n      get: function get() {\n        var nodes = [];\n        var slots = this.__slots;\n        if (slots) {\n          for (var name in slots) {\n            var slot = slots[name];\n            var childNodes = slot.childNodes;\n            var childNodesLen = childNodes.length;\n            for (var a = 0; a < childNodesLen; a++) {\n              nodes.push(childNodes[a]);\n            }\n          }\n        }\n        return makeLikeNodeList(nodes);\n      }\n    },\n    children: {\n      get: function get() {\n        return makeLikeNodeList(this.childNodes.filter(function (node) {\n          return node.nodeType === 1;\n        }));\n      }\n    },\n    firstChild: {\n      get: function get() {\n        return this.childNodes[0] || null;\n      }\n    },\n    firstElementChild: {\n      get: function get() {\n        return this.children[0] || null;\n      }\n    },\n    innerHTML: {\n      get: function get() {\n        return this.childNodes.map(function (node) {\n          return node.outerHTML || node.textContent;\n        }).join('');\n      },\n      set: function set(val) {\n        var div = document.createElement('div');\n        var frag = document.createDocumentFragment();\n\n        // TODO: This may not be foolproof with incompatible child nodes.\n        div.innerHTML = val;\n\n        // Ensure existing nodes are cleaned up properly.\n        while (this.hasChildNodes()) {\n          this.removeChild(this.firstChild);\n        }\n\n        // Ensures new nodes are set up properly.\n        while (div.hasChildNodes()) {\n          frag.appendChild(div.firstChild);\n        }\n\n        this.appendChild(frag);\n      }\n    },\n    lastChild: {\n      get: function get() {\n        var ch = this.childNodes;\n        return ch[ch.length - 1] || null;\n      }\n    },\n    lastElementChild: {\n      get: function get() {\n        var ch = this.children;\n        return ch[ch.length - 1] || null;\n      }\n    },\n    outerHTML: {\n      get: function get() {\n        var name = this.tagName.toLowerCase();\n        var attributes = toArray(this.attributes).map(function (attr) {\n          return ' ' + attr.name + (attr.value ? '=\"' + attr.value + '\"' : '');\n        }).join('');\n        return '<' + name + attributes + '>' + this.innerHTML + '</' + name + '>';\n      }\n    },\n    textContent: {\n      get: function get() {\n        return this.childNodes.map(function (node) {\n          return node.textContent;\n        }).join('');\n      },\n      set: function set(val) {\n        // Ensure existing nodes are cleaned up properly.\n        while (this.hasChildNodes()) {\n          this.removeChild(this.firstChild);\n        }\n\n        doForNodesIfSlot(this, val.toString(), function (elem, node, slot) {\n          slot.textContent = node;\n        });\n      }\n    }\n  };\n\n  // Method overrides.\n\n  var funcs = {\n    appendChild: function appendChild(newNode) {\n      doForNodesIfSlot(this, newNode, function (elem, node, slot) {\n        slot.appendChild(node);\n        applyParentNode(node, elem);\n      });\n      return newNode;\n    },\n    hasChildNodes: function hasChildNodes() {\n      return this.childNodes.length > 0;\n    },\n    insertBefore: function insertBefore(newNode, refNode) {\n      doForNodesIfSlot(this, newNode, function (elem, node, slot) {\n        slot.insertBefore(node, refNode);\n        applyParentNode(node, elem);\n      });\n      return newNode;\n    },\n    removeChild: function removeChild(refNode) {\n      doForNodesIfSlot(this, refNode, function (elem, node, slot) {\n        slot.removeChild(node);\n        removeParentNode(node);\n      });\n      return refNode;\n    },\n    replaceChild: function replaceChild(newNode, refNode) {\n      doForNodesIfSlot(this, newNode, function (elem, node, slot) {\n        slot.replaceChild(node, refNode);\n        applyParentNode(node, elem);\n      });\n      removeParentNode(refNode);\n      return refNode;\n    }\n  };\n\n  // Polyfill the prototypes if we can.\n  if (canPatchNativeAccessors) {\n    // Patch the HTMLElement prototype if we can as it's the highest in the\n    // prototype chain we need to worry about.\n    Object.defineProperties(htmlElProto, descendantAccessors);\n  }\n\n  // Polyfills an element.\n  function polyfill (elem) {\n    if (mapPolyfilled.get(elem)) {\n      return;\n    }\n\n    // Polyfill properties.\n    for (var name in props) {\n      prop(elem, name, props[name]);\n    }\n\n    // Polyfill methods.\n    for (var name in funcs) {\n      elem[name] = funcs[name];\n    }\n\n    mapPolyfilled.set(elem, true);\n    return elem;\n  }\n\n  // Returns whether or not the specified element has been polyfilled.\n  function polyfilled (elem) {\n    return mapPolyfilled.get(elem);\n  }\n\n  // Returns a document fragment of the childNodes of the specified element. Due\n  // to the nature of the DOM, this will remove the nodes from the element.\n  function createFragmentFromChildNodes(elem) {\n    var frag = document.createDocumentFragment();\n    while (elem.hasChildNodes()) {\n      frag.appendChild(elem.firstChild);\n    }\n    return frag;\n  }\n\n  // Creates an shadow root, appends it to the element and returns it.\n  function createShadowRoot(elem) {\n    var root = document.createElement(isBlockLevel(elem) ? 'div' : 'span');\n    elem.appendChild(root);\n    return root;\n  }\n\n  // Returns whether or not the specified element is a block level element or not\n  // We need this to determine the type of element the shadow root should be\n  // since we must use real nodes to simulate a shadow root.\n  function isBlockLevel(elem) {\n    return window.getComputedStyle(elem).display === 'block';\n  }\n\n  // Simple renderer that proxies another renderer. It will polyfill if not yet\n  // polyfilled, or simply run the renderer. Initial content is taken into\n  // consideration.\n  var defaults = { shadowId: '' };\n  function render (fn) {\n    var opts = arguments.length <= 1 || arguments[1] === undefined ? defaults : arguments[1];\n\n    return function (elem) {\n      var shadowRoot = elem.__shadowRoot;\n\n      if (shadowRoot) {\n        fn(elem, shadowRoot);\n      } else {\n        // We get a fragment of the initial DOM so that we can create the shadow\n        // root.\n        var initialLightDom = createFragmentFromChildNodes(elem);\n\n        // Create a shadow ID so that it can be used to get a slot that is unique\n        // to this shadow root. Since we don't polyfill querySelector() et al, we\n        // need a way to be able to refer to slots that are unique to this\n        // shadow root.\n        elem.__shadowId = opts.shadowId;\n\n        // Create the shadow root and return the light DOM. We must get the light\n        // DOM before we template it so that we can distribute it after\n        // polyfilling.\n        elem.__shadowRoot = createShadowRoot(elem);\n\n        // Render once we have the initial light DOM as this would likely blow\n        // that away.\n        fn(elem, elem.__shadowRoot);\n\n        // Now polyfill so that we can distribute after.\n        polyfill(elem);\n\n        // Distribute the initial light DOM after polyfill so they get put into\n        // the right spots.\n        elem.appendChild(initialLightDom);\n      }\n    };\n  }\n\n  var version = '0.0.1';\n\n\n\n  var api = Object.freeze({\n  \tdefault: polyfill,\n  \tpolyfilled: polyfilled,\n  \trender: render,\n  \tversion: version\n  });\n\n  var previousGlobal = window.skatejsNamedSlots;\n  polyfill.noConflict = function noConflict() {\n    window.skatejsNamedSlots = previousGlobal;\n    return this;\n  };\n  window.skatejsNamedSlots = polyfill;\n  for (var name in api) {\n    polyfill[name] = api[name];\n  }\n\n  return polyfill;\n\n}));\n//# sourceMappingURL=index.js.map"],"sourceRoot":"/source/"}