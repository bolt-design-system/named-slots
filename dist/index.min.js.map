{"version":3,"file":"index.min.js","sources":["../src/util/each.js","../src/util/get-property-descriptor.js","../src/util/can-patch-native-accessors.js","../node_modules/date-now/index.js","../node_modules/debounce/index.js","../src/util/get-escaped-text-content.js","../src/util/get-comment-node-outer-html.js","../src/version.js","../node_modules/weakmap/weakmap.js","../node_modules/custom-event-polyfill/custom-event-polyfill.js","../src/index.js"],"sourcesContent":["export function eachChildNode(node, func) {\n  if (!node) {\n    return;\n  }\n\n  const chs = node.childNodes;\n  const chsLen = chs.length;\n  for (let a = 0; a < chsLen; a++) {\n    const ret = func(chs[a], a, chs);\n    if (typeof ret !== 'undefined') {\n      return ret; // eslint-disable-line consistent-return\n    }\n  }\n}\n\nexport function eachNodeOrFragmentNodes(node, func) {\n  if (node instanceof DocumentFragment) {\n    const chs = node.childNodes;\n    const chsLen = chs.length;\n    for (let a = 0; a < chsLen; a++) {\n      func(chs[a], a);\n    }\n  } else {\n    func(node, 0);\n  }\n}\n","const div = document.createElement('div');\n\nfunction getPrototype(obj, key) {\n  let descriptor;\n\n  while (obj && !(descriptor = Object.getOwnPropertyDescriptor(obj, key))) { // eslint-disable-line no-cond-assign\n    obj = Object.getPrototypeOf(obj);\n  }\n  return descriptor;\n}\nexport default function (obj, key) {\n  if (obj instanceof Node) {\n    obj = div;\n  }\n  const proto = getPrototype(obj, key);\n\n  if (proto) {\n    const getter = proto.get;\n    const setter = proto.set;\n    const descriptor = {\n      configurable: true,\n      enumerable: true,\n    };\n\n    if (getter) {\n      descriptor.get = getter;\n      descriptor.set = setter;\n      return descriptor;\n    } else if (typeof obj[key] === 'function') {\n      descriptor.value = obj[key];\n      return descriptor;\n    }\n  }\n\n  const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n  if (descriptor && descriptor.get) {\n    return descriptor;\n  }\n}\n","// Any code referring to this is because it has to work around this bug in\n// WebKit: https://bugs.webkit.org/show_bug.cgi?id=49739\n\nimport getPropertyDescriptor from './get-property-descriptor';\n\nconst nativeParentNode = getPropertyDescriptor(Element.prototype, 'innerHTML');\n\nexport default !!nativeParentNode;\n","module.exports = Date.now || now\n\nfunction now() {\n    return new Date().getTime()\n}\n","\n/**\n * Module dependencies.\n */\n\nvar now = require('date-now');\n\n/**\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * N milliseconds. If `immediate` is passed, trigger the function on the\n * leading edge, instead of the trailing.\n *\n * @source underscore.js\n * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n * @param {Function} function to wrap\n * @param {Number} timeout in ms (`100`)\n * @param {Boolean} whether to execute at the beginning (`false`)\n * @api public\n */\n\nmodule.exports = function debounce(func, wait, immediate){\n  var timeout, args, context, timestamp, result;\n  if (null == wait) wait = 100;\n\n  function later() {\n    var last = now() - timestamp;\n\n    if (last < wait && last > 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      if (!immediate) {\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      }\n    }\n  };\n\n  return function debounced() {\n    context = this;\n    args = arguments;\n    timestamp = now();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n};\n","/**\n * See https://w3c.github.io/DOM-Parsing/#serializing\n * @param {TextNode}\n * @returns {string}\n */\nexport default function getEscapedTextContent(textNode) {\n  return textNode.textContent.replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;');\n}\n","/**\n * @returns {string}\n * @param {commentNode}\n */\nexport default function getCommentNodeOuterHtml(commentNode) {\n  return commentNode.text || `<!--${commentNode.textContent}-->`;\n}\n","export default '0.0.1';\n","/* (The MIT License)\r\n *\r\n * Copyright (c) 2012 Brandon Benvie <http://bbenvie.com>\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and\r\n * associated documentation files (the 'Software'), to deal in the Software without restriction,\r\n * including without limitation the rights to use, copy, modify, merge, publish, distribute,\r\n * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included with all copies or\r\n * substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\r\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  CLAIM,\r\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n// Original WeakMap implementation by Gozala @ https://gist.github.com/1269991\r\n// Updated and bugfixed by Raynos @ https://gist.github.com/1638059\r\n// Expanded by Benvie @ https://github.com/Benvie/harmony-collections\r\n\r\nvoid function(global, undefined_, undefined){\r\n  var getProps = Object.getOwnPropertyNames,\r\n      defProp  = Object.defineProperty,\r\n      toSource = Function.prototype.toString,\r\n      create   = Object.create,\r\n      hasOwn   = Object.prototype.hasOwnProperty,\r\n      funcName = /^\\n?function\\s?(\\w*)?_?\\(/;\r\n\r\n\r\n  function define(object, key, value){\r\n    if (typeof key === 'function') {\r\n      value = key;\r\n      key = nameOf(value).replace(/_$/, '');\r\n    }\r\n    return defProp(object, key, { configurable: true, writable: true, value: value });\r\n  }\r\n\r\n  function nameOf(func){\r\n    return typeof func !== 'function'\r\n          ? '' : 'name' in func\r\n          ? func.name : toSource.call(func).match(funcName)[1];\r\n  }\r\n\r\n  // ############\r\n  // ### Data ###\r\n  // ############\r\n\r\n  var Data = (function(){\r\n    var dataDesc = { value: { writable: true, value: undefined } },\r\n        datalock = 'return function(k){if(k===s)return l}',\r\n        uids     = create(null),\r\n\r\n        createUID = function(){\r\n          var key = Math.random().toString(36).slice(2);\r\n          return key in uids ? createUID() : uids[key] = key;\r\n        },\r\n\r\n        globalID = createUID(),\r\n\r\n        storage = function(obj){\r\n          if (hasOwn.call(obj, globalID))\r\n            return obj[globalID];\r\n\r\n          if (!Object.isExtensible(obj))\r\n            throw new TypeError(\"Object must be extensible\");\r\n\r\n          var store = create(null);\r\n          defProp(obj, globalID, { value: store });\r\n          return store;\r\n        };\r\n\r\n    // common per-object storage area made visible by patching getOwnPropertyNames'\r\n    define(Object, function getOwnPropertyNames(obj){\r\n      var props = getProps(obj);\r\n      if (hasOwn.call(obj, globalID))\r\n        props.splice(props.indexOf(globalID), 1);\r\n      return props;\r\n    });\r\n\r\n    function Data(){\r\n      var puid = createUID(),\r\n          secret = {};\r\n\r\n      this.unlock = function(obj){\r\n        var store = storage(obj);\r\n        if (hasOwn.call(store, puid))\r\n          return store[puid](secret);\r\n\r\n        var data = create(null, dataDesc);\r\n        defProp(store, puid, {\r\n          value: new Function('s', 'l', datalock)(secret, data)\r\n        });\r\n        return data;\r\n      }\r\n    }\r\n\r\n    define(Data.prototype, function get(o){ return this.unlock(o).value });\r\n    define(Data.prototype, function set(o, v){ this.unlock(o).value = v });\r\n\r\n    return Data;\r\n  }());\r\n\r\n\r\n  var WM = (function(data){\r\n    var validate = function(key){\r\n      if (key == null || typeof key !== 'object' && typeof key !== 'function')\r\n        throw new TypeError(\"Invalid WeakMap key\");\r\n    }\r\n\r\n    var wrap = function(collection, value){\r\n      var store = data.unlock(collection);\r\n      if (store.value)\r\n        throw new TypeError(\"Object is already a WeakMap\");\r\n      store.value = value;\r\n    }\r\n\r\n    var unwrap = function(collection){\r\n      var storage = data.unlock(collection).value;\r\n      if (!storage)\r\n        throw new TypeError(\"WeakMap is not generic\");\r\n      return storage;\r\n    }\r\n\r\n    var initialize = function(weakmap, iterable){\r\n      if (iterable !== null && typeof iterable === 'object' && typeof iterable.forEach === 'function') {\r\n        iterable.forEach(function(item, i){\r\n          if (item instanceof Array && item.length === 2)\r\n            set.call(weakmap, iterable[i][0], iterable[i][1]);\r\n        });\r\n      }\r\n    }\r\n\r\n\r\n    function WeakMap(iterable){\r\n      if (this === global || this == null || this === WeakMap.prototype)\r\n        return new WeakMap(iterable);\r\n\r\n      wrap(this, new Data);\r\n      initialize(this, iterable);\r\n    }\r\n\r\n    function get(key){\r\n      validate(key);\r\n      var value = unwrap(this).get(key);\r\n      return value === undefined_ ? undefined : value;\r\n    }\r\n\r\n    function set(key, value){\r\n      validate(key);\r\n      // store a token for explicit undefined so that \"has\" works correctly\r\n      unwrap(this).set(key, value === undefined ? undefined_ : value);\r\n    }\r\n\r\n    function has(key){\r\n      validate(key);\r\n      return unwrap(this).get(key) !== undefined;\r\n    }\r\n\r\n    function delete_(key){\r\n      validate(key);\r\n      var data = unwrap(this),\r\n          had = data.get(key) !== undefined;\r\n      data.set(key, undefined);\r\n      return had;\r\n    }\r\n\r\n    function toString(){\r\n      unwrap(this);\r\n      return '[object WeakMap]';\r\n    }\r\n\r\n    try {\r\n      var src = ('return '+delete_).replace('e_', '\\\\u0065'),\r\n          del = new Function('unwrap', 'validate', src)(unwrap, validate);\r\n    } catch (e) {\r\n      var del = delete_;\r\n    }\r\n\r\n    var src = (''+Object).split('Object');\r\n    var stringifier = function toString(){\r\n      return src[0] + nameOf(this) + src[1];\r\n    };\r\n\r\n    define(stringifier, stringifier);\r\n\r\n    var prep = { __proto__: [] } instanceof Array\r\n      ? function(f){ f.__proto__ = stringifier }\r\n      : function(f){ define(f, stringifier) };\r\n\r\n    prep(WeakMap);\r\n\r\n    [toString, get, set, has, del].forEach(function(method){\r\n      define(WeakMap.prototype, method);\r\n      prep(method);\r\n    });\r\n\r\n    return WeakMap;\r\n  }(new Data));\r\n\r\n  var defaultCreator = Object.create\r\n    ? function(){ return Object.create(null) }\r\n    : function(){ return {} };\r\n\r\n  function createStorage(creator){\r\n    var weakmap = new WM;\r\n    creator || (creator = defaultCreator);\r\n\r\n    function storage(object, value){\r\n      if (value || arguments.length === 2) {\r\n        weakmap.set(object, value);\r\n      } else {\r\n        value = weakmap.get(object);\r\n        if (value === undefined) {\r\n          value = creator(object);\r\n          weakmap.set(object, value);\r\n        }\r\n      }\r\n      return value;\r\n    }\r\n\r\n    return storage;\r\n  }\r\n\r\n\r\n  if (typeof module !== 'undefined') {\r\n    module.exports = WM;\r\n  } else if (typeof exports !== 'undefined') {\r\n    exports.WeakMap = WM;\r\n  } else if (!('WeakMap' in global)) {\r\n    global.WeakMap = WM;\r\n  }\r\n\r\n  WM.createStorage = createStorage;\r\n  if (global.WeakMap)\r\n    global.WeakMap.createStorage = createStorage;\r\n}((0, eval)('this'));\r\n","// Polyfill for creating CustomEvents on IE9/10/11\n\n// code pulled from:\n// https://github.com/d4tocchini/customevent-polyfill\n// https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent#Polyfill\n\ntry {\n    var ce = new window.CustomEvent('test', {\n        bubbles: false,\n        cancelable: true,\n        detail: {\n            x: 'y'\n        }\n    });\n    ce.preventDefault();\n    if (ce.defaultPrevented !== true) {\n        // IE has problems with .preventDefault() on custom events\n        // http://stackoverflow.com/questions/23349191\n        throw new Error('Could not prevent default');\n    }\n} catch(e) {\n var CustomEvent = function(event, params) {\n      var evt;\n      params = params || {\n          bubbles: false,\n          cancelable: false,\n          detail: undefined\n      };\n\n      evt = document.createEvent(\"CustomEvent\");\n      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n      var origPrevent = evt.preventDefault;\n      evt.preventDefault = function () {\n          origPrevent.call(this);\n          try {\n              Object.defineProperty(this, 'defaultPrevented', {\n                  get: function () {\n                      return true;\n                  }\n              });\n          } catch(e) {\n              this.defaultPrevented = true;\n          }\n      };\n      return evt;\n  };\n\n  CustomEvent.prototype = window.Event.prototype;\n  window.CustomEvent = CustomEvent; // expose definition to window\n}\n","import { eachChildNode, eachNodeOrFragmentNodes } from './util/each';\nimport canPatchNativeAccessors from './util/can-patch-native-accessors';\nimport getPropertyDescriptor from './util/get-property-descriptor';\nimport debounce from 'debounce';\nimport getEscapedTextContent from './util/get-escaped-text-content';\nimport getCommentNodeOuterHtml from './util/get-comment-node-outer-html';\nimport version from './version';\nimport WeakMap from 'weakmap';\nimport 'custom-event-polyfill';\n\nconst arrProto = Array.prototype;\nconst { forEach } = arrProto;\n\n// We use a real DOM node for a shadow root. This is because the host node\n// basically becomes a virtual entry point for your element leaving the shadow\n// root the only thing that can receive instructions on how the host should\n// render to the browser.\nconst defaultShadowRootTagName = '_shadow_root_';\nconst defaultShadowRootTagNameUc = defaultShadowRootTagName.toUpperCase();\n\n// * WebKit only *\n//\n// These members we need cannot override as we require native access to their\n// original values at some point.\nconst polyfillAtRuntime = ['childNodes', 'parentNode'];\n\n// Some properties that should not be overridden in the Text prototype.\nconst doNotOverridePropertiesInTextNodes = ['textContent'];\n\n// Some new properties that should be defined in the Text prototype.\nconst defineInTextNodes = ['assignedSlot'];\n\n// Some properties that should not be overridden in the Comment prototype.\nconst doNotOverridePropertiesInCommNodes = ['textContent'];\n\n// Some new properties that should be defined in the Comment prototype.\nconst defineInCommNodes = [];\n\n// Nodes that should be slotted\nconst slottedNodeTypes = [Node.ELEMENT_NODE, Node.TEXT_NODE];\n\n// Private data stores.\nconst assignedToSlotMap = new WeakMap();\nconst hostToModeMap = new WeakMap();\nconst hostToRootMap = new WeakMap();\nconst nodeToChildNodesMap = new WeakMap();\nconst nodeToParentNodeMap = new WeakMap();\nconst nodeToSlotMap = new WeakMap();\nconst rootToHostMap = new WeakMap();\nconst rootToSlotMap = new WeakMap();\nconst slotToRootMap = new WeakMap();\n\n\n// Unfortunately manual DOM parsing is because of WebKit.\nconst parser = new DOMParser();\nfunction parse(html) {\n  const tree = document.createElement('div');\n\n  // Everything not WebKit can do this easily.\n  if (canPatchNativeAccessors) {\n    tree.__innerHTML = html;\n    return tree;\n  }\n\n  const parsed = parser.parseFromString(`<div>${html}</div>`, 'text/html').body.firstChild;\n\n  while (parsed.hasChildNodes()) {\n    const firstChild = parsed.firstChild;\n    parsed.removeChild(firstChild);\n    tree.appendChild(firstChild);\n  }\n\n  // Need to import the node to initialise the custom elements from the parser.\n  return document.importNode(tree, true);\n}\n\nfunction staticProp(obj, name, value) {\n  Object.defineProperty(obj, name, {\n    configurable: true,\n    get() { return value; },\n  });\n}\n\n\n// Slotting helpers.\n\nfunction arrayItem(idx) {\n  return this[idx];\n}\n\nfunction makeLikeNodeList(arr) {\n  arr.item = arrayItem;\n  return arr;\n}\n\nfunction isHostNode(node) {\n  return !!hostToRootMap.get(node);\n}\n\nfunction isSlotNode(node) {\n  return node.tagName === 'SLOT';\n}\n\nfunction isRootNode(node) {\n  return node.tagName === defaultShadowRootTagNameUc;\n}\n\nfunction getNodeType(node) {\n  if (isHostNode(node)) {\n    return 'host';\n  }\n\n  if (isSlotNode(node)) {\n    return 'slot';\n  }\n\n  if (isRootNode(node)) {\n    return 'root';\n  }\n\n  return 'node';\n}\n\nfunction findClosest(node, func) {\n  while (node) {\n    if (node === document) {\n      break;\n    }\n    if (func(node)) {\n      return node;\n    }\n    node = node.parentNode;\n  }\n}\n\nfunction getSlotNameFromSlot(node) {\n  return node.getAttribute && node.getAttribute('name') || 'default';\n}\n\nfunction getSlotNameFromNode(node) {\n  return node.getAttribute && node.getAttribute('slot') || 'default';\n}\n\nfunction slotNodeIntoSlot(slot, node, insertBefore) {\n  // Don't slot nodes that have content but are only whitespace. This is an\n  // anomaly that I don't think the spec deals with.\n  //\n  // The problem is:\n  //\n  // - If you insert HTML with indentation into the page, there will be\n  //   whitespace and if that's inserted it messes with fallback content\n  //   calculation where there is formatting, but no meaningful content, so in\n  //   theory it should fallback. Since you can attach a shadow root after we\n  //   mean to insert an empty text node and have it \"count\", we can't really\n  //   discard nodes that are considered formatting at the time of attachment.\n  // - You can insert a text node and modify its text content later.\n  //   Incremental DOM seems to do this. Every way I look at it, it seems\n  //   problematic that we should have to screen for content, but I don't seems\n  //   much of a way around it at the moment.\n  if (node.nodeType === 3 && node.textContent && node.textContent.trim().length === 0) {\n    return;\n  }\n\n  // only Text and Element nodes should be slotted\n  if (slottedNodeTypes.indexOf(node.nodeType) === -1) {\n    return;\n  }\n\n  const assignedNodes = slot.assignedNodes();\n  const shouldGoIntoContentMode = assignedNodes.length === 0;\n  const slotInsertBeforeIndex = assignedNodes.indexOf(insertBefore);\n\n  // Assign the slot to the node internally.\n  nodeToSlotMap.set(node, slot);\n\n  // Remove the fallback content and state if we're going into content mode.\n  if (shouldGoIntoContentMode) {\n    forEach.call(slot.childNodes, child => slot.__removeChild(child));\n  }\n\n  if (slotInsertBeforeIndex > -1) {\n    slot.__insertBefore(node, insertBefore !== undefined ? insertBefore : null);\n    assignedNodes.splice(slotInsertBeforeIndex, 0, node);\n  } else {\n    slot.__appendChild(node);\n    assignedNodes.push(node);\n  }\n\n  slot.____triggerSlotChangeEvent();\n}\n\nfunction slotNodeFromSlot(node) {\n  const slot = node.assignedSlot;\n\n  if (slot) {\n    const assignedNodes = slot.assignedNodes();\n    const index = assignedNodes.indexOf(node);\n\n    if (index > -1) {\n      const shouldGoIntoDefaultMode = assignedNodes.length === 1;\n\n      assignedNodes.splice(index, 1);\n      nodeToSlotMap.set(node, null);\n\n      // Actually remove the child.\n      slot.__removeChild(node);\n\n      // If this was the last slotted node, then insert fallback content.\n      if (shouldGoIntoDefaultMode) {\n        forEach.call(slot.childNodes, child => slot.__appendChild(child));\n      }\n\n      slot.____triggerSlotChangeEvent();\n    }\n  }\n}\n\n// Returns the index of the node in the host's childNodes.\nfunction indexOfNode(host, node) {\n  const chs = host.childNodes;\n  const chsLen = chs.length;\n  for (let a = 0; a < chsLen; a++) {\n    if (chs[a] === node) {\n      return a;\n    }\n  }\n  return -1;\n}\n\n// Adds the node to the list of childNodes on the host and fakes any necessary\n// information such as parentNode.\nfunction registerNode(host, node, insertBefore, func) {\n  const index = indexOfNode(host, insertBefore);\n  eachNodeOrFragmentNodes(node, (eachNode, eachIndex) => {\n    func(eachNode, eachIndex);\n\n    if (canPatchNativeAccessors) {\n      nodeToParentNodeMap.set(eachNode, host);\n    } else {\n      staticProp(eachNode, 'parentNode', host);\n    }\n\n    if (index > -1) {\n      arrProto.splice.call(host.childNodes, index + eachIndex, 0, eachNode);\n    } else {\n      arrProto.push.call(host.childNodes, eachNode);\n    }\n  });\n}\n\n// Cleans up registerNode().\nfunction unregisterNode(host, node, func) {\n  const index = indexOfNode(host, node);\n\n  if (index > -1) {\n    func(node, 0);\n\n    if (canPatchNativeAccessors) {\n      nodeToParentNodeMap.set(node, null);\n    } else {\n      staticProp(node, 'parentNode', null);\n    }\n\n    arrProto.splice.call(host.childNodes, index, 1);\n  }\n}\n\nfunction addNodeToNode(host, node, insertBefore) {\n  registerNode(host, node, insertBefore, eachNode => {\n    host.__insertBefore(eachNode, insertBefore !== undefined ? insertBefore : null);\n  });\n}\n\nfunction addNodeToHost(host, node, insertBefore) {\n  registerNode(host, node, insertBefore, eachNode => {\n    const rootNode = hostToRootMap.get(host);\n    const slotNodes = rootToSlotMap.get(rootNode);\n    const slotNode = slotNodes[getSlotNameFromNode(eachNode)];\n    if (slotNode) {\n      slotNodeIntoSlot(slotNode, eachNode, insertBefore);\n    }\n  });\n}\n\nfunction addSlotToRoot(root, slot) {\n  const slotName = getSlotNameFromSlot(slot);\n\n  // Ensure a slot node's childNodes are overridden at the earliest point\n  // possible for WebKit.\n  if (!canPatchNativeAccessors && !slot.childNodes.push) {\n    staticProp(slot, 'childNodes', [...slot.childNodes]);\n  }\n\n  rootToSlotMap.get(root)[slotName] = slot;\n\n  if (!slotToRootMap.has(slot)) {\n    slotToRootMap.set(slot, root);\n  }\n\n  eachChildNode(rootToHostMap.get(root), eachNode => {\n    if (!eachNode.assignedSlot && slotName === getSlotNameFromNode(eachNode)) {\n      slotNodeIntoSlot(slot, eachNode);\n    }\n  });\n}\n\nfunction addNodeToRoot(root, node, insertBefore) {\n  eachNodeOrFragmentNodes(node, child => {\n    if (isSlotNode(child)) {\n      addSlotToRoot(root, child);\n    } else {\n      const slotNodes = child.querySelectorAll && child.querySelectorAll('slot');\n      if (slotNodes) {\n        const slotNodesLen = slotNodes.length;\n        for (let a = 0; a < slotNodesLen; a++) {\n          addSlotToRoot(root, slotNodes[a]);\n        }\n      }\n    }\n  });\n  addNodeToNode(root, node, insertBefore);\n}\n\n// Adds a node to a slot. In other words, adds default content to a slot. It\n// ensures that if the slot doesn't have any assigned nodes yet, that the node\n// is actually displayed, otherwise it's just registered as child content.\nfunction addNodeToSlot(slot, node, insertBefore) {\n  const isInDefaultMode = slot.assignedNodes().length === 0;\n  registerNode(slot, node, insertBefore, eachNode => {\n    if (isInDefaultMode) {\n      slot.__insertBefore(eachNode, insertBefore !== undefined ? insertBefore : null);\n    }\n  });\n}\n\n// Removes a node from a slot (default content). It ensures that if the slot\n// doesn't have any assigned nodes yet, that the node is actually removed,\n// otherwise it's just unregistered.\nfunction removeNodeFromSlot(slot, node) {\n  const isInDefaultMode = slot.assignedNodes().length === 0;\n  unregisterNode(slot, node, () => {\n    if (isInDefaultMode) {\n      slot.__removeChild(node);\n    }\n  });\n}\n\nfunction removeNodeFromNode(host, node) {\n  unregisterNode(host, node, () => {\n    host.__removeChild(node);\n  });\n}\n\nfunction removeNodeFromHost(host, node) {\n  unregisterNode(host, node, () => {\n    slotNodeFromSlot(node);\n  });\n}\n\nfunction removeSlotFromRoot(root, node) {\n  node.assignedNodes().forEach(slotNodeFromSlot);\n  delete rootToSlotMap.get(root)[getSlotNameFromSlot(node)];\n  slotToRootMap.delete(node);\n}\n\nfunction removeNodeFromRoot(root, node) {\n  unregisterNode(root, node, () => {\n    if (isSlotNode(node)) {\n      removeSlotFromRoot(root, node);\n    } else {\n      const nodes = node.querySelectorAll && node.querySelectorAll('slot');\n      if (nodes) {\n        for (let a = 0; a < nodes.length; a++) {\n          removeSlotFromRoot(root, nodes[a]);\n        }\n      }\n    }\n    root.__removeChild(node);\n  });\n}\n\n// TODO terribly inefficient\nfunction getRootNode(host) {\n  if (isRootNode(host)) {\n    return host;\n  }\n\n  if (!host.parentNode) {\n    return;\n  }\n\n  return getRootNode(host.parentNode);\n}\n\nfunction appendChildOrInsertBefore(host, newNode, refNode) {\n  const nodeType = getNodeType(host);\n  const parentNode = newNode.parentNode;\n  const rootNode = getRootNode(host);\n\n  // Ensure childNodes is patched so we can manually update it for WebKit.\n  if (!canPatchNativeAccessors && !host.childNodes.push) {\n    staticProp(host, 'childNodes', [...host.childNodes]);\n  }\n\n  if (rootNode && getNodeType(newNode) === 'slot') {\n    addSlotToRoot(rootNode, newNode);\n  }\n\n  // If we append a child to a host, the host tells the shadow root to distribute\n  // it. If the root decides it doesn't need to be distributed, it is never\n  // removed from the old parent because in polyfill land we store a reference\n  // to the node but we don't move it. Due to that, we must explicitly remove the\n  // node from its old parent.\n  if (parentNode && getNodeType(parentNode) === 'host') {\n    if (canPatchNativeAccessors) {\n      nodeToParentNodeMap.set(newNode, null);\n    } else {\n      staticProp(newNode, 'parentNode', null);\n    }\n  }\n\n  if (nodeType === 'node') {\n    if (canPatchNativeAccessors) {\n      nodeToParentNodeMap.set(newNode, host);\n      return host.__insertBefore(newNode, refNode !== undefined ? refNode : null);\n    }\n\n    return addNodeToNode(host, newNode, refNode);\n  }\n\n  if (nodeType === 'slot') {\n    return addNodeToSlot(host, newNode, refNode);\n  }\n\n  if (nodeType === 'host') {\n    return addNodeToHost(host, newNode, refNode);\n  }\n\n  if (nodeType === 'root') {\n    return addNodeToRoot(host, newNode, refNode);\n  }\n}\n\nfunction syncSlotChildNodes(firstChild) {\n  if (canPatchNativeAccessors && getNodeType(firstChild) === 'slot' && (firstChild.__childNodes.length !== firstChild.childNodes.length)) {\n    while (firstChild.hasChildNodes()) {\n      firstChild.removeChild(firstChild.firstChild);\n    }\n\n    for (let i = 0; i < firstChild.__childNodes.length; i++) {\n      firstChild.appendChild(firstChild.__childNodes[i]);\n    }\n  }\n}\n\nconst members = {\n  // For testing purposes.\n  ____assignedNodes: {\n    get() {\n      return this.______assignedNodes || (this.______assignedNodes = []);\n    },\n  },\n\n  // For testing purposes.\n  ____isInFallbackMode: {\n    get() {\n      return this.assignedNodes().length === 0;\n    },\n  },\n\n  ____slotChangeListeners: {\n    get() {\n      if (typeof this.______slotChangeListeners === 'undefined') {\n        this.______slotChangeListeners = 0;\n      }\n      return this.______slotChangeListeners;\n    },\n    set(value) {\n      this.______slotChangeListeners = value;\n    },\n  },\n  ____triggerSlotChangeEvent: {\n    value: debounce(function callback() {\n      if (this.____slotChangeListeners) {\n        this.dispatchEvent(new CustomEvent('slotchange', {\n          bubbles: false,\n          cancelable: false,\n        }));\n      }\n    }),\n  },\n  addEventListener: {\n    value(name, func, opts) {\n      if (name === 'slotchange' && isSlotNode(this)) {\n        this.____slotChangeListeners++;\n      }\n      return this.__addEventListener(name, func, opts);\n    },\n  },\n  appendChild: {\n    value(newNode) {\n      return appendChildOrInsertBefore(this, newNode);\n    },\n  },\n  assignedSlot: {\n    get() {\n      const slot = nodeToSlotMap.get(this);\n\n      if (!slot) {\n        return null;\n      }\n\n      const root = slotToRootMap.get(slot);\n      const host = rootToHostMap.get(root);\n      const mode = hostToModeMap.get(host);\n\n      return mode === 'open' ? slot : null;\n    },\n  },\n  attachShadow: {\n    value(opts) {\n      const mode = opts && opts.mode;\n      if (mode !== 'closed' && mode !== 'open') {\n        throw new Error('You must specify { mode } as \"open\" or \"closed\" to attachShadow().');\n      }\n\n      // Return the existing shadow root if it exists.\n      const existingShadowRoot = hostToRootMap.get(this);\n      if (existingShadowRoot) {\n        return existingShadowRoot;\n      }\n\n      const lightNodes = makeLikeNodeList([].slice.call(this.childNodes));\n      const shadowRoot = document.createElement(opts.polyfillShadowRootTagName || defaultShadowRootTagName);\n\n      // Host and shadow root data.\n      hostToModeMap.set(this, mode);\n      hostToRootMap.set(this, shadowRoot);\n      rootToHostMap.set(shadowRoot, this);\n      rootToSlotMap.set(shadowRoot, {});\n\n      if (canPatchNativeAccessors) {\n        nodeToChildNodesMap.set(this, lightNodes);\n      } else {\n        staticProp(this, 'childNodes', lightNodes);\n      }\n\n      // Process light DOM.\n      lightNodes.forEach(node => {\n        // Existing children should be removed from being displayed, but still\n        // appear to be child nodes. This is how light DOM works; they're still\n        // child nodes but not in the composed DOM yet as there won't be any\n        // slots for them to go into.\n        this.__removeChild(node);\n\n        // We must register the parentNode here as this has the potential to\n        // become out of sync if the node is moved before being slotted.\n        if (canPatchNativeAccessors) {\n          nodeToParentNodeMap.set(node, this);\n        } else {\n          staticProp(node, 'parentNode', this);\n        }\n      });\n\n      // The shadow root is actually the only child of the host.\n      return this.__appendChild(shadowRoot);\n    },\n  },\n  childElementCount: {\n    get() {\n      return this.children.length;\n    },\n  },\n  childNodes: {\n    get() {\n      if (canPatchNativeAccessors && getNodeType(this) === 'node') {\n        return this.__childNodes;\n      }\n      let childNodes = nodeToChildNodesMap.get(this);\n\n      if (!childNodes) {\n        nodeToChildNodesMap.set(this, childNodes = makeLikeNodeList([]));\n      }\n\n      return childNodes;\n    },\n  },\n  children: {\n    get() {\n      const chs = [];\n      eachChildNode(this, node => {\n        if (node.nodeType === 1) {\n          chs.push(node);\n        }\n      });\n      return makeLikeNodeList(chs);\n    },\n  },\n  firstChild: {\n    get() {\n      return this.childNodes[0] || null;\n    },\n  },\n  firstElementChild: {\n    get() {\n      return this.children[0] || null;\n    },\n  },\n  assignedNodes: {\n    value() {\n      if (isSlotNode(this)) {\n        let assigned = assignedToSlotMap.get(this);\n\n        if (!assigned) {\n          assignedToSlotMap.set(this, assigned = []);\n        }\n\n        return assigned;\n      }\n    },\n  },\n  hasChildNodes: {\n    value() {\n      return this.childNodes.length > 0;\n    },\n  },\n  innerHTML: {\n    get() {\n      let innerHTML = '';\n\n      const getHtmlNodeOuterHtml = (node) => node.outerHTML;\n      const getOuterHtmlByNodeType = {\n        1: getHtmlNodeOuterHtml,\n        3: getEscapedTextContent,\n        8: getCommentNodeOuterHtml,\n      };\n\n      eachChildNode(this, node => {\n        const getOuterHtml = getOuterHtmlByNodeType[node.nodeType] || getHtmlNodeOuterHtml;\n        innerHTML += getOuterHtml(node);\n      });\n      return innerHTML;\n    },\n    set(innerHTML) {\n      const parsed = parse(innerHTML);\n\n      while (this.hasChildNodes()) {\n        this.removeChild(this.firstChild);\n      }\n\n      while (parsed.hasChildNodes()) {\n        const firstChild = parsed.firstChild;\n\n        // when we are doing this: root.innerHTML = \"<slot><div></div></slot>\";\n        // slot.__childNodes is out of sync with slot.childNodes.\n        // to fix it we have to manually remove and insert them\n        syncSlotChildNodes(firstChild);\n\n        // When we polyfill everything on HTMLElement.prototype, we overwrite\n        // properties. This makes it so that parentNode reports null even though\n        // it's actually a parent of the HTML parser. For this reason,\n        // cleanNode() won't work and we must manually remove it from the\n        // parser before it is moved to the host just in case it's added as a\n        // light node but not assigned to a slot.\n        parsed.removeChild(firstChild);\n\n        this.appendChild(firstChild);\n      }\n    },\n  },\n  insertBefore: {\n    value(newNode, refNode) {\n      return appendChildOrInsertBefore(this, newNode, refNode);\n    },\n  },\n  lastChild: {\n    get() {\n      const ch = this.childNodes;\n      return ch[ch.length - 1] || null;\n    },\n  },\n  lastElementChild: {\n    get() {\n      const ch = this.children;\n      return ch[ch.length - 1] || null;\n    },\n  },\n  name: {\n    get() {\n      return this.getAttribute('name');\n    },\n    set(name) {\n      return this.setAttribute('name', name);\n    },\n  },\n  nextSibling: {\n    get() {\n      const host = this;\n      return eachChildNode(this.parentNode, (child, index, nodes) => {\n        if (host === child) {\n          return nodes[index + 1] || null;\n        }\n      });\n    },\n  },\n  nextElementSibling: {\n    get() {\n      const host = this;\n      let found;\n      return eachChildNode(this.parentNode, child => {\n        if (found && child.nodeType === 1) {\n          return child;\n        }\n        if (host === child) {\n          found = true;\n        }\n      });\n    },\n  },\n  outerHTML: {\n    get() {\n      const name = this.tagName.toLowerCase();\n      const attributes = Array.prototype.slice.call(this.attributes).map((attr) =>\n        (` ${attr.name}${attr.value ? `=\"${attr.value}\"` : ''}`)\n      ).join('');\n      return `<${name}${attributes}>${this.innerHTML}</${name}>`;\n    },\n\n    set(outerHTML) {\n      if (this.parentNode) {\n        const parsed = parse(outerHTML);\n        this.parentNode.replaceChild(parsed.firstChild, this);\n      } else {\n        if (canPatchNativeAccessors) {\n          this.__outerHTML = outerHTML;  // this will throw a native error;\n        } else {\n          throw new Error('Failed to set the \\'outerHTML\\' property on \\'Element\\': This element has no parent node.');\n        }\n      }\n    },\n  },\n  parentElement: {\n    get() {\n      return findClosest(this.parentNode, (node) => node.nodeType === 1);\n    },\n  },\n  parentNode: {\n    get() {\n      return nodeToParentNodeMap.get(this) || this.__parentNode || null;\n    },\n  },\n  previousSibling: {\n    get() {\n      const host = this;\n      return eachChildNode(this.parentNode, (child, index, nodes) => {\n        if (host === child) {\n          return nodes[index - 1] || null;\n        }\n      });\n    },\n  },\n  previousElementSibling: {\n    get() {\n      const host = this;\n      let found;\n      return eachChildNode(this.parentNode, child => {\n        if (found && host === child) {\n          return found;\n        }\n        if (child.nodeType === 1) {\n          found = child;\n        }\n      });\n    },\n  },\n  removeChild: {\n    value(refNode) {\n      const nodeType = getNodeType(this);\n\n      if (nodeType === 'node') {\n        if (canPatchNativeAccessors) {\n          return this.__removeChild(refNode);\n        }\n\n        return removeNodeFromNode(this, refNode);\n      }\n\n      if (nodeType === 'slot') {\n        return removeNodeFromSlot(this, refNode);\n      }\n\n      if (nodeType === 'host') {\n        return removeNodeFromHost(this, refNode);\n      }\n\n      if (nodeType === 'root') {\n        return removeNodeFromRoot(this, refNode);\n      }\n    },\n  },\n  removeEventListener: {\n    value(name, func, opts) {\n      if (name === 'slotchange' && this.____slotChangeListeners && isSlotNode(this)) {\n        this.____slotChangeListeners--;\n      }\n      return this.__removeEventListener(name, func, opts);\n    },\n  },\n  replaceChild: {\n    value(newNode, refNode) {\n      this.insertBefore(newNode, refNode);\n      return this.removeChild(refNode);\n    },\n  },\n  shadowRoot: {\n    get() {\n      return hostToModeMap.get(this) === 'open' ? hostToRootMap.get(this) : null;\n    },\n  },\n  textContent: {\n    get() {\n      let textContent = '';\n      eachChildNode(this, node => {\n        if (node.nodeType !== Node.COMMENT_NODE) {\n          textContent += node.textContent;\n        }\n      });\n      return textContent;\n    },\n    set(textContent) {\n      while (this.hasChildNodes()) {\n        this.removeChild(this.firstChild);\n      }\n      if (!textContent) {\n        return;\n      }\n      this.appendChild(document.createTextNode(textContent));\n    },\n  },\n};\n\nif (!('attachShadow' in document.createElement('div'))) {\n  const elementProto = HTMLElement.prototype;\n  const textProto = Text.prototype;\n  const commProto = Comment.prototype;\n  const textNode = document.createTextNode('');\n  const commNode = document.createComment('');\n\n  Object.keys(members).forEach(memberName => {\n    const memberProperty = members[memberName];\n\n    // All properties should be configurable.\n    memberProperty.configurable = true;\n\n    // Applying to the data properties only since we can't have writable accessor properties.\n    if (memberProperty.hasOwnProperty('value')) {\n      memberProperty.writable = true;\n    }\n\n    // Polyfill as much as we can and work around WebKit in other areas.\n    if (canPatchNativeAccessors || polyfillAtRuntime.indexOf(memberName) === -1) {\n      const nativeDescriptor = getPropertyDescriptor(elementProto, memberName);\n      const nativeTextDescriptor = getPropertyDescriptor(textProto, memberName);\n      const nativeCommDescriptor = getPropertyDescriptor(commProto, memberName);\n      const shouldOverrideInTextNode = (memberName in textNode && doNotOverridePropertiesInTextNodes.indexOf(memberName) === -1) || ~defineInTextNodes.indexOf(memberName);\n      const shouldOverrideInCommentNode = (memberName in commNode && doNotOverridePropertiesInCommNodes.indexOf(memberName) === -1) || ~defineInCommNodes.indexOf(memberName);\n      const nativeMemberName = `__${memberName}`;\n\n      Object.defineProperty(elementProto, memberName, memberProperty);\n\n      if (nativeDescriptor) {\n        Object.defineProperty(elementProto, nativeMemberName, nativeDescriptor);\n      }\n\n      if (shouldOverrideInTextNode) {\n        Object.defineProperty(textProto, memberName, memberProperty);\n      }\n\n      if (shouldOverrideInTextNode && nativeTextDescriptor) {\n        Object.defineProperty(textProto, nativeMemberName, nativeTextDescriptor);\n      }\n\n      if (shouldOverrideInCommentNode) {\n        Object.defineProperty(commProto, memberName, memberProperty);\n      }\n\n      if (shouldOverrideInCommentNode && nativeCommDescriptor) {\n        Object.defineProperty(commProto, nativeMemberName, nativeCommDescriptor);\n      }\n    }\n  });\n}\n\nexport default version;\n"],"names":["eachChildNode","node","func","chs","childNodes","chsLen","length","a","ret","eachNodeOrFragmentNodes","DocumentFragment","getPrototype","obj","key","descriptor","Object","getOwnPropertyDescriptor","getPrototypeOf","Node","div","proto","getter","get","setter","set","_descriptor","value","getEscapedTextContent","textNode","textContent","replace","getCommentNodeOuterHtml","commentNode","text","parse","html","tree","document","createElement","canPatchNativeAccessors","__innerHTML","parsed","parser","parseFromString","body","firstChild","hasChildNodes","removeChild","appendChild","importNode","staticProp","name","defineProperty","arrayItem","idx","this","makeLikeNodeList","arr","item","isHostNode","hostToRootMap","isSlotNode","tagName","isRootNode","defaultShadowRootTagNameUc","getNodeType","findClosest","parentNode","getSlotNameFromSlot","getAttribute","getSlotNameFromNode","slotNodeIntoSlot","slot","insertBefore","nodeType","trim","slottedNodeTypes","indexOf","assignedNodes","shouldGoIntoContentMode","slotInsertBeforeIndex","call","__removeChild","child","__insertBefore","undefined","splice","__appendChild","push","____triggerSlotChangeEvent","slotNodeFromSlot","assignedSlot","index","shouldGoIntoDefaultMode","indexOfNode","host","registerNode","eachNode","eachIndex","unregisterNode","addNodeToNode","addNodeToHost","rootNode","slotNodes","rootToSlotMap","slotNode","addSlotToRoot","root","slotName","slotToRootMap","has","rootToHostMap","addNodeToRoot","querySelectorAll","slotNodesLen","addNodeToSlot","isInDefaultMode","removeNodeFromSlot","removeNodeFromNode","removeNodeFromHost","removeSlotFromRoot","forEach","removeNodeFromRoot","nodes","getRootNode","appendChildOrInsertBefore","newNode","refNode","syncSlotChildNodes","__childNodes","i","nativeParentNode","getPropertyDescriptor","Element","prototype","now","Date","getTime","module","exports","require$$0","wait","immediate","later","last","timestamp","setTimeout","apply","context","args","timeout","result","arguments","callNow","global","undefined_","define","object","nameOf","defProp","configurable","writable","toSource","match","funcName","createStorage","creator","storage","weakmap","WM","defaultCreator","getProps","getOwnPropertyNames","Function","toString","create","hasOwn","hasOwnProperty","Data","puid","createUID","secret","unlock","store","data","dataDesc","datalock","uids","Math","random","slice","globalID","isExtensible","TypeError","props","o","v","WeakMap","iterable","unwrap","delete_","had","validate","wrap","collection","initialize","Array","src","del","e","split","stringifier","prep","__proto__","f","method","eval","ce","window","CustomEvent","preventDefault","defaultPrevented","Error","event","params","evt","createEvent","initCustomEvent","bubbles","cancelable","detail","origPrevent","Event","arrProto","defaultShadowRootTagName","toUpperCase","polyfillAtRuntime","doNotOverridePropertiesInTextNodes","defineInTextNodes","doNotOverridePropertiesInCommNodes","defineInCommNodes","ELEMENT_NODE","TEXT_NODE","assignedToSlotMap","hostToModeMap","nodeToChildNodesMap","nodeToParentNodeMap","nodeToSlotMap","DOMParser","members","______assignedNodes","______slotChangeListeners","debounce","____slotChangeListeners","dispatchEvent","opts","__addEventListener","mode","existingShadowRoot","lightNodes","shadowRoot","polyfillShadowRootTagName","children","assigned","innerHTML","getHtmlNodeOuterHtml","outerHTML","getOuterHtmlByNodeType","getOuterHtml","ch","setAttribute","found","toLowerCase","attributes","map","attr","join","replaceChild","__outerHTML","__parentNode","__removeEventListener","COMMENT_NODE","createTextNode","elementProto","HTMLElement","textProto","Text","commProto","Comment","commNode","createComment","keys","memberProperty","memberName","nativeDescriptor","nativeTextDescriptor","nativeCommDescriptor","shouldOverrideInTextNode","shouldOverrideInCommentNode","nativeMemberName"],"mappings":"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"}