{"version":3,"file":"index.js","sources":["../node_modules/debounce/node_modules/date-now/index.js","../node_modules/debounce/index.js","../src/internal/get-slot.js","../src/internal/weak-map.js","../src/internal/map-node-is-light-dom.js","../src/internal/map-polyfilled.js","../src/internal/map-polyfilled-light-node.js","../src/internal/map-polyfilled-parent-node.js","../src/internal/map-slot-change-listeners.js","../src/internal/prop.js","../src/polyfill.js","../src/polyfilled.js","../src/render.js","../src/version.js","../src/index.js","../src/global.js"],"sourcesContent":["module.exports = Date.now || now\n\nfunction now() {\n    return new Date().getTime()\n}\n","\n/**\n * Module dependencies.\n */\n\nvar now = require('date-now');\n\n/**\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * N milliseconds. If `immediate` is passed, trigger the function on the\n * leading edge, instead of the trailing.\n *\n * @source underscore.js\n * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n * @param {Function} function to wrap\n * @param {Number} timeout in ms (`100`)\n * @param {Boolean} whether to execute at the beginning (`false`)\n * @api public\n */\n\nmodule.exports = function debounce(func, wait, immediate){\n  var timeout, args, context, timestamp, result;\n  if (null == wait) wait = 100;\n\n  function later() {\n    var last = now() - timestamp;\n\n    if (last < wait && last > 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      if (!immediate) {\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      }\n    }\n  };\n\n  return function debounced() {\n    context = this;\n    args = arguments;\n    timestamp = now();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n};\n","import debounce from 'debounce';\n\nfunction polyfillSlot (slot) {\n  slot.__triggerSlotChangeEvent = debounce(triggerSlotChangeEvent);\n  return slot;\n}\n\nfunction queryForNamedSlot (host, name) {\n  return host.querySelector(`slot[name=\"${name}\"], [slot-name=\"${name}\"]`);\n}\n\nfunction queryForUnnamedSlot (host) {\n  return host.querySelector('slot[name=\"\"], slot:not([name]), [slot-name=\"\"]');\n}\n\nfunction triggerSlotChangeEvent () {\n  this.dispatchEvent(new CustomEvent('slotchange', {\n    bubbles: false,\n    cancelable: false\n  }));\n}\n\nexport default function (host, node) {\n  if (!node) {\n    return;\n  }\n\n  const slotName = node.getAttribute && node.getAttribute('slot');\n  const cacheKey = slotName || 'content';\n\n  if (!host.__slots) {\n    host.__slots = {};\n  }\n\n  const slots = host.__slots;\n\n  // We check for a cached slot first because querying is slow.\n  if (slots[cacheKey]) {\n    const slotElement = slots[cacheKey];\n\n    // However, we check to see if it was detached. If not, just return it.\n    if (slotElement.parentNode) {\n      return slotElement;\n    }\n\n    // if it was detached we should make sure it's cleaned up.\n    delete slots[cacheKey];\n    return null;\n  }\n\n  const calculatedName = (host.__shadowId || '') + (slotName || '');\n  const slotElement = slotName ? queryForNamedSlot(host, calculatedName) : queryForUnnamedSlot(host);\n\n  // Cache it because querying is slow.\n  if (slotElement) {\n    slots[cacheKey] = polyfillSlot(slotElement);\n  }\n\n  return slots[cacheKey] || null;\n}\n","export default window.WeakMap || (function () {\n  let index = 0;\n  function Wm () {\n    this.key = `____weak_map_${index++}`;\n  }\n  Wm.prototype = {\n    delete (obj) {\n      delete obj[this.key];\n    },\n    get (obj) {\n      return obj[this.key];\n    },\n    has (obj) {\n      return typeof obj[this.key] !== 'undefined';\n    },\n    set (obj, val) {\n      return obj[this.key] = val;\n    }\n  };\n  return Wm;\n}());\n","import WeakMap from './weak-map';\nexport default new WeakMap();\n","import WeakMap from './weak-map';\nexport default new WeakMap();\n","import WeakMap from './weak-map';\nexport default new WeakMap();\n","import WeakMap from './weak-map';\nexport default new WeakMap();\n","import WeakMap from './weak-map';\nexport default new WeakMap();\n","export default Object.defineProperty.bind(Object);\n","import getSlot from './internal/get-slot';\nimport mapNodeIsLightDom from './internal/map-node-is-light-dom';\nimport mapPolyfilled from './internal/map-polyfilled';\nimport mapPolyfilledLightNode from './internal/map-polyfilled-light-node';\nimport mapPolyfilledParentNode from './internal/map-polyfilled-parent-node';\nimport mapSlotChangeListeners from './internal/map-slot-change-listeners';\nimport prop from './internal/prop';\n\nconst nodeProto = Node.prototype;\nconst elProto = Element.prototype;\nconst htmlElProto = HTMLElement.prototype;\n\nconst configurable = true;\nconst canPatchNativeAccessors = !!Object.getOwnPropertyDescriptor(Node.prototype, 'parentNode').get;\n\n// Fake parentNode helpers.\n\nfunction applyParentNode (node, parent) {\n  mapNodeIsLightDom.set(node, true);\n  mapPolyfilledParentNode.set(node, parent);\n\n  if (!canPatchNativeAccessors && !mapPolyfilledLightNode.get(node)) {\n    mapPolyfilledLightNode.set(node, true);\n    for (let name in lightProps) {\n      prop(node, name, lightProps[name]);\n    }\n  }\n}\n\nfunction removeParentNode (node) {\n  mapNodeIsLightDom.set(node, false);\n  mapPolyfilledParentNode.set(node, null);\n}\n\n\n// Slotting helpers.\n\nfunction arrayItem (idx) {\n  return this[idx];\n}\n\nfunction doForNodesIfSlot (elem, node, func) {\n  const nodes = nodeToArray(node);\n  const nodesLen = nodes.length;\n\n  for (let a = 0; a < nodesLen; a++) {\n    const node = nodes[a];\n    const slot = getSlot(elem, node);\n\n    if (slot) {\n      func(elem, node, slot);\n      if (mapSlotChangeListeners.get(slot)) {\n        slot.__triggerSlotChangeEvent();\n      }\n    }\n  }\n}\n\nfunction makeLikeNodeList (arr) {\n  arr.item = arrayItem;\n  return arr;\n}\n\nfunction nodeToArray (node) {\n  return node instanceof DocumentFragment ? toArray(node.childNodes) : [node];\n}\n\nfunction toArray (obj) {\n  return Array.prototype.slice.call(obj);\n}\n\n\n// Prop overrides.\n\nconst hostProps = {\n  childElementCount: {\n    configurable,\n    get () {\n      return this.children.length;\n    }\n  },\n  childNodes: {\n    get () {\n      let nodes = [];\n      const slots = this.__slots;\n      if (slots) {\n        for (let name in slots) {\n          const slot = slots[name];\n          const childNodes = slot.childNodes;\n          const childNodesLen = childNodes.length;\n          for (let a = 0; a < childNodesLen; a++) {\n            nodes.push(childNodes[a]);\n          }\n        }\n      }\n      return makeLikeNodeList(nodes);\n    }\n  },\n  children: {\n    get () {\n      return makeLikeNodeList(this.childNodes.filter(node => node.nodeType === 1));\n    }\n  },\n  firstChild: {\n    get () {\n      return this.childNodes[0] || null;\n    }\n  },\n  firstElementChild: {\n    get () {\n      return this.children[0] || null;\n    }\n  },\n  innerHTML: {\n    get () {\n      return this.childNodes.map(node => node.outerHTML || node.textContent).join('');\n    },\n    set (val) {\n      const div = document.createElement('div');\n      const frag = document.createDocumentFragment();\n\n      // TODO: This may not be foolproof with incompatible child nodes.\n      div.innerHTML = val;\n\n      // Ensure existing nodes are cleaned up properly.\n      while (this.hasChildNodes()) {\n        this.removeChild(this.firstChild);\n      }\n\n      // Ensures new nodes are set up properly.\n      while (div.hasChildNodes()) {\n        frag.appendChild(div.firstChild);\n      }\n\n      this.appendChild(frag);\n    }\n  },\n  lastChild: {\n    get () {\n      const ch = this.childNodes;\n      return ch[ch.length - 1] || null;\n    }\n  },\n  lastElementChild: {\n    get () {\n      const ch = this.children;\n      return ch[ch.length - 1] || null;\n    }\n  },\n  outerHTML: {\n    get () {\n      const name = this.tagName.toLowerCase();\n      const attributes = toArray(this.attributes).map(function (attr) {\n        return ` ${attr.name}${attr.value ? `=\"${attr.value}\"` : ''}`;\n      }).join('');\n      return `<${name}${attributes}>${this.innerHTML}</${name}>`;\n    }\n  },\n  textContent: {\n    get () {\n      return this.childNodes.map(node => node.textContent).join('');\n    },\n    set (val) {\n      // Ensure existing nodes are cleaned up properly.\n      while (this.hasChildNodes()) {\n        this.removeChild(this.firstChild);\n      }\n\n      doForNodesIfSlot(this, val.toString(), function (elem, node, slot) {\n        slot.textContent = node;\n      });\n    }\n  }\n};\n\nconst lightProps = {\n  parentElement: {\n    configurable,\n    get () {\n      if (mapNodeIsLightDom.get(this)) {\n        const parent = this.parentNode;\n        return parent.nodeType === 1 ? parent : null;\n      }\n      return this.__parentElement;\n    }\n  },\n  parentNode: {\n    configurable,\n    get () {\n      return mapPolyfilledParentNode.get(this) || this.__parentNode || null;\n    }\n  },\n  nextSibling: {\n    configurable,\n    get () {\n      if (mapNodeIsLightDom.get(this)) {\n        let index;\n        const parChs = this.parentNode.childNodes;\n        const parChsLen = parChs.length;\n        for (let a = 0; a < parChsLen; a++) {\n          if (parChs[a] === this) {\n            index = a;\n            continue;\n          }\n        }\n        return typeof index === 'number' ? parChs[index + 1] : null;\n      }\n      return this.__nextSibling;\n    }\n  },\n  nextElementSibling: {\n    configurable,\n    get () {\n      if (mapNodeIsLightDom.get(this)) {\n        let next;\n        while ((next = this.nextSibling)) {\n          if (next.nodeType === 1) {\n            return next;\n          }\n        }\n        return null;\n      }\n      return this.__nextElementSibling;\n    }\n  },\n  previousSibling: {\n    configurable,\n    get () {\n      if (mapNodeIsLightDom.get(this)) {\n        let index;\n        const parChs = this.parentNode.childNodes;\n        const parChsLen = parChs.length;\n        for (let a = 0; a < parChsLen; a++) {\n          if (parChs[a] === this) {\n            index = a;\n            continue;\n          }\n        }\n        return typeof index === 'number' ? parChs[index - 1] : null;\n      }\n      return this.__previousSibling;\n    }\n  },\n  previousElementSibling: {\n    configurable,\n    get () {\n      if (mapNodeIsLightDom.get(this)) {\n        let prev;\n        while ((prev = this.previousSibling)) {\n          if (prev.nodeType === 1) {\n            return prev;\n          }\n        }\n        return null;\n      }\n      return this.__previousElementSibling;\n    }\n  }\n};\n\n\n// Method overrides.\n\nconst funcs = {\n  appendChild (newNode) {\n    doForNodesIfSlot(this, newNode, function (elem, node, slot) {\n      slot.appendChild(node);\n      applyParentNode(node, elem);\n    });\n    return newNode;\n  },\n  hasChildNodes () {\n    return this.childNodes.length > 0;\n  },\n  insertBefore (newNode, refNode) {\n    doForNodesIfSlot(this, newNode, function (elem, node, slot) {\n      slot.insertBefore(node, refNode);\n      applyParentNode(node, elem);\n    });\n    return newNode;\n  },\n  removeChild (refNode) {\n    doForNodesIfSlot(this, refNode, function (elem, node, slot) {\n      slot.removeChild(node);\n      removeParentNode(node);\n    });\n    return refNode;\n  },\n  replaceChild (newNode, refNode) {\n    // If the ref node is not in the light DOM, just return it.\n    if (refNode.parentNode !== this) {\n      return refNode;\n    }\n\n    // We're dealing with a representation of the light DOM, so we insert nodes\n    // relative to the location of the refNode in the light DOM, not the where\n    // it appears in the composed DOM.\n    const insertBefore = refNode.nextSibling;\n\n    // Clean up the reference node.\n    this.removeChild(refNode);\n\n    // Add new nodes in place of the reference node.\n    doForNodesIfSlot(this, newNode, function (elem, node, slot) {\n      slot.insertBefore(node, insertBefore);\n      applyParentNode(node, elem);\n    });\n\n    return refNode;\n  }\n};\n\n\n// If we can patch native accessors, we can safely apply light DOM accessors to\n// all HTML elements. This is faster than polyfilling them individually as they\n// are added, if possible, and doesn't have a measurable impact on performance\n// when they're not marked as light DOM.\nif (canPatchNativeAccessors) {\n  for (let name in lightProps) {\n    const proto = nodeProto.hasOwnProperty(name) ? nodeProto : elProto;\n    prop(proto, `__${name}`, Object.getOwnPropertyDescriptor(proto, name));\n    prop(proto, name, lightProps[name]);\n  }\n}\n\n\n// Patch add/removeEventListener() so that we can keep track of slotchange\n// events. Since we support <slot> elements and normal elements - due to some\n// quirks that cannot be polyfilled - we add this to HTMLElement.\nconst addEventListener = htmlElProto.addEventListener;\nconst removeEventListener = htmlElProto.removeEventListener;\nhtmlElProto.addEventListener = function (name, func, opts) {\n  if (name === 'slotchange') {\n    let listeners = mapSlotChangeListeners.get(this) || 0;\n    mapSlotChangeListeners.set(this, ++listeners);\n  }\n  return addEventListener.call(this, name, func, opts);\n};\nhtmlElProto.removeEventListener = function (name, func, opts) {\n  if (name === 'slotchange') {\n    let listeners = mapSlotChangeListeners.get(this) || 1;\n    mapSlotChangeListeners.set(this, --listeners);\n  }\n  return removeEventListener.call(this, name, func, opts);\n};\n\n\n// Polyfills a host element.\nexport default function polyfill (elem) {\n  if (mapPolyfilled.get(elem)) {\n    return;\n  }\n\n  for (let name in hostProps) {\n    prop(elem, name, hostProps[name]);\n  }\n\n  for (let name in funcs) {\n    elem[name] = funcs[name];\n  }\n\n  mapPolyfilled.set(elem, true);\n  return elem;\n}\n","import mapPolyfilled from './internal/map-polyfilled';\n\n// Returns whether or not the specified element has been polyfilled.\nexport default function (elem) {\n  return mapPolyfilled.get(elem);\n}\n","import polyfill from './polyfill';\n\n// Returns a document fragment of the childNodes of the specified element. Due\n// to the nature of the DOM, this will remove the nodes from the element.\nfunction createFragmentFromChildNodes (elem) {\n  const frag = document.createDocumentFragment();\n  while (elem.hasChildNodes()) {\n    frag.appendChild(elem.firstChild);\n  }\n  return frag;\n}\n\n// Creates an shadow root, appends it to the element and returns it.\nfunction createShadowRoot (elem) {\n  const root = document.createElement(isBlockLevel(elem) ? 'div' : 'span');\n  elem.appendChild(root);\n  return root;\n}\n\n// Returns whether or not the specified element is a block level element or not\n// We need this to determine the type of element the shadow root should be\n// since we must use real nodes to simulate a shadow root.\nfunction isBlockLevel (elem) {\n  return window.getComputedStyle(elem).display === 'block';\n}\n\n// Simple renderer that proxies another renderer. It will polyfill if not yet\n// polyfilled, or simply run the renderer. Initial content is taken into\n// consideration.\nconst defaults = { shadowId: '' };\nexport default function (fn, opts = defaults) {\n  return function (elem) {\n    let shadowRoot = elem.__shadowRoot;\n\n    if (shadowRoot) {\n      fn(elem, shadowRoot);\n    } else {\n      // We get a fragment of the initial DOM so that we can create the shadow\n      // root.\n      const initialLightDom = createFragmentFromChildNodes(elem);\n\n      // Create a shadow ID so that it can be used to get a slot that is unique\n      // to this shadow root. Since we don't polyfill querySelector() et al, we\n      // need a way to be able to refer to slots that are unique to this\n      // shadow root.\n      elem.__shadowId = opts.shadowId;\n\n      // Create the shadow root and return the light DOM. We must get the light\n      // DOM before we template it so that we can distribute it after\n      // polyfilling.\n      elem.__shadowRoot = createShadowRoot(elem);\n\n      // Render once we have the initial light DOM as this would likely blow\n      // that away.\n      fn(elem, elem.__shadowRoot);\n\n      // Now polyfill so that we can distribute after.\n      polyfill(elem);\n\n      // Distribute the initial light DOM after polyfill so they get put into\n      // the right spots.\n      elem.appendChild(initialLightDom);\n    }\n  };\n}\n","export default '0.0.1';\n","import polyfill from './polyfill';\nimport polyfilled from './polyfilled';\nimport render from './render';\nimport version from './version';\n\nexport default polyfill;\nexport {\n  polyfilled,\n  render,\n  version\n};\n","\n  import main, * as api from '../src/index.js';\n  const previousGlobal = window.skatejsNamedSlots;\n  main.noConflict = function noConflict () {\n    window.skatejsNamedSlots = previousGlobal;\n    return this;\n  };\n  window.skatejsNamedSlots = main;\n  for (let name in api) {\n    main[name] = api[name];\n  }\n  export default main;\n"],"names":["name","main"],"mappings":"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"}